<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
<title>OVERTIME - 3v3 Hockey</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
body{background:#000;overflow:hidden;font-family:'Segoe UI',Arial,sans-serif;-webkit-user-select:none;user-select:none;touch-action:none}
canvas{display:block}
#startScreen{position:fixed;inset:0;z-index:200;background:linear-gradient(135deg,#0a1628 0%,#1a3a5c 50%,#0a1628 100%);display:flex;flex-direction:column;align-items:center;justify-content:center}
#startScreen h1{font-size:min(18vw,100px);color:#fff;text-shadow:0 0 40px #4af,0 0 80px #28f;letter-spacing:8px;margin-bottom:8px;font-weight:900}
#startScreen .sub{color:#8cf;font-size:min(5vw,20px);margin-bottom:40px;letter-spacing:4px}
#playBtn{font-size:min(7vw,32px);padding:18px 60px;background:linear-gradient(180deg,#e33,#b00);color:#fff;border:none;border-radius:50px;cursor:pointer;letter-spacing:3px;font-weight:700;touch-action:manipulation;box-shadow:0 4px 20px rgba(255,0,0,0.4)}
#hud{position:fixed;top:8px;left:50%;transform:translateX(-50%);z-index:50;background:rgba(0,0,0,0.85);border-radius:12px;padding:6px 20px;color:#fff;text-align:center;display:none}
#hud .score{font-size:26px;font-weight:bold}
#hud .score .blue{color:#4af}
#hud .score .red{color:#f44}
#hud .info{font-size:12px;color:#888}
#goalFlash{position:fixed;inset:0;z-index:100;display:none;align-items:center;justify-content:center;pointer-events:none;background:rgba(255,0,0,0.15)}
#goalFlash span{font-size:min(15vw,80px);font-weight:900;color:#fff;text-shadow:0 0 40px red}
#minimap{position:fixed;top:50px;right:10px;z-index:40;border-radius:6px;border:1px solid rgba(255,255,255,0.2);pointer-events:none;display:none}
.joyEl{position:fixed;border-radius:50%;pointer-events:none;z-index:20;display:none}
#lJoyBase{width:110px;height:110px;border:2px solid rgba(255,255,255,0.2);background:rgba(255,255,255,0.05)}
#lJoyKnob{width:46px;height:46px;background:rgba(255,255,255,0.3)}
#rJoyBase{width:110px;height:110px;border:2px solid rgba(255,100,100,0.2);background:rgba(255,60,60,0.05)}
#rJoyKnob{width:46px;height:46px;background:rgba(255,100,100,0.3)}
#faceoffText{position:fixed;top:25%;left:50%;transform:translate(-50%,-50%);z-index:60;font-size:min(12vw,60px);font-weight:900;color:#fff;text-shadow:0 0 30px rgba(255,255,255,0.5);display:none;pointer-events:none}
#gameOverlay{position:fixed;inset:0;z-index:90;display:none;flex-direction:column;align-items:center;justify-content:center;background:rgba(0,0,0,0.7);pointer-events:auto}
#gameOverlay h2{font-size:min(12vw,60px);color:#fff;margin-bottom:10px}
#gameOverlay p{font-size:min(8vw,36px);color:#fff;margin-bottom:30px}
#gameOverlay .sub{font-size:min(5vw,20px);color:#888}
#controlHint{position:fixed;bottom:10px;left:50%;transform:translateX(-50%);z-index:40;color:rgba(255,255,255,0.4);font-size:11px;pointer-events:none;display:none;text-align:center}
</style>
</head>
<body>
<div id="startScreen">
  <h1>OVERTIME</h1>
  <div class="sub">3 v 3 HOCKEY</div>
  <button id="playBtn">â–¶ PLAY</button>
</div>
<div id="hud">
  <div class="score"><span class="blue" id="sBlue">0</span> â€” <span class="red" id="sRed">0</span></div>
  <div class="info">P<span id="sPer">1</span> Â· <span id="sTime">2:00</span></div>
</div>
<div id="goalFlash"><span>ðŸš¨ GOAL!</span></div>
<div id="faceoffText">FACE OFF</div>
<div id="gameOverlay"><h2>GAME OVER</h2><p id="winText"></p><div class="sub">Tap to play again</div></div>
<canvas id="minimap" width="140" height="60"></canvas>
<div id="lJoyBase" class="joyEl"></div>
<div id="lJoyKnob" class="joyEl"></div>
<div id="rJoyBase" class="joyEl"></div>
<div id="rJoyKnob" class="joyEl"></div>
<div id="controlHint">WASD = Skate &nbsp;|&nbsp; Arrows = Stick</div>

<script type="importmap">
{"imports":{"three":"https://cdn.jsdelivr.net/npm/three@0.162.0/build/three.module.js"}}
</script>
<script type="module">
import * as THREE from 'three';

const isMobile = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
let W = window.innerWidth, H = window.innerHeight;

// ========== THREE.JS SETUP ==========
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x060a14);
scene.fog = new THREE.FogExp2(0x060a14, 0.003);

const camera = new THREE.PerspectiveCamera(72, W / H, 0.1, 400);
const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });
renderer.setSize(W, H);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.1;
document.body.prepend(renderer.domElement);

window.addEventListener('resize', () => {
  W = window.innerWidth; H = window.innerHeight;
  camera.aspect = W / H; camera.updateProjectionMatrix();
  renderer.setSize(W, H);
});

// Lights â€” bright arena lighting
scene.add(new THREE.AmbientLight(0x667788, 0.7));
scene.add(new THREE.HemisphereLight(0xaabbdd, 0x333344, 0.6));
// Arena overhead lights (brighter, whiter)
for (let i = 0; i < 6; i++) {
  const pl = new THREE.PointLight(0xfff8f0, 1.5, 200, 1.2);
  pl.position.set(-80 + i * 32, 40, 0);
  scene.add(pl);
}
// Side lights for board visibility
for (let i = 0; i < 4; i++) {
  for (const sz of [-1, 1]) {
    const sl = new THREE.PointLight(0xfff8f0, 0.4, 80, 2);
    sl.position.set(-60 + i * 40, 15, sz * 35);
    scene.add(sl);
  }
}
const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
dirLight.position.set(0, 50, 10);
scene.add(dirLight);

// ========== CONSTANTS ==========
const RW = 200, RH = 85, CX = 100, CY = 42.5;
const PERIOD_SECS = 120;
const PR = 5, PKR = 2, GR = 5.5, GOAL_W = 14;
const ACCEL = 280, FRICTION = 0.91, MAX_SPD = 95;
const STICK_LEN = 8;       // how far blade tip extends from player center
const CONTACT_R = 3.5;     // blade-puck contact radius
const STICK_POWER = 1.2;   // multiplier for blade speed â†’ puck speed
const SHOT_SPD = 260;
const CARRY_FORCE = 300;   // force/sec when carrying puck on blade

function G(gx, gy) { return [gx - 100, gy - 42.5]; }

// ========== BUILD RINK ==========
function buildRink() {
  // Arena shell â€” darker ceiling, slightly visible walls
  const arenaMat = new THREE.MeshBasicMaterial({ color: 0x0c1020, side: THREE.BackSide });
  const arena = new THREE.Mesh(new THREE.BoxGeometry(320, 80, 220), arenaMat);
  arena.position.y = 35; scene.add(arena);

  // Crowd stands â€” rows of colored seats
  for (let side of [-1, 1]) {
    // Lower bowl (darker, closer)
    const lower = new THREE.Mesh(new THREE.PlaneGeometry(240, 15),
      new THREE.MeshBasicMaterial({ color: 0x222240 }));
    lower.position.set(0, 12, side * 62); lower.rotation.y = side > 0 ? Math.PI : 0;
    scene.add(lower);
    // Upper bowl
    const upper = new THREE.Mesh(new THREE.PlaneGeometry(240, 20),
      new THREE.MeshBasicMaterial({ color: 0x1a1a30 }));
    upper.position.set(0, 28, side * 75); upper.rotation.y = side > 0 ? Math.PI : 0;
    scene.add(upper);
    // Crowd dots (random colored patches to simulate people)
    for (let i = 0; i < 80; i++) {
      const cx = -100 + Math.random() * 200;
      const cy = 6 + Math.random() * 25;
      const colors = [0xcc3333, 0x3355cc, 0xeeeeee, 0xffcc00, 0x44aa44, 0xff6600];
      const dot = new THREE.Mesh(new THREE.PlaneGeometry(1.5 + Math.random(), 1.5 + Math.random()),
        new THREE.MeshBasicMaterial({ color: colors[Math.floor(Math.random() * colors.length)] }));
      dot.position.set(cx, cy, side * (62 + Math.random() * 15));
      dot.rotation.y = side > 0 ? Math.PI : 0;
      scene.add(dot);
    }
  }

  const iceMat = new THREE.MeshStandardMaterial({ color: 0xe0e8f0, roughness: 0.15, metalness: 0 });
  const ice = new THREE.Mesh(new THREE.PlaneGeometry(RW, RH), iceMat);
  ice.rotation.x = -Math.PI / 2; scene.add(ice);

  // Realistic hockey boards: yellow kick plate, white dasher, yellow cap, clear glass
  const kickMat = new THREE.MeshStandardMaterial({ color: 0xddaa00, roughness: 0.6 }); // yellow kick plate
  const dasherMat = new THREE.MeshStandardMaterial({ color: 0xeeeeee, roughness: 0.4 }); // white dasher
  const capMat = new THREE.MeshStandardMaterial({ color: 0xddaa00, roughness: 0.4 }); // yellow top rail
  const redStripeMat = new THREE.MeshStandardMaterial({ color: 0xcc2222, roughness: 0.5 }); // red stripe
  const bT = 1.2;
  const kickH = 1.2, dasherH = 2.8, totalH = kickH + dasherH;

  for (const sz of [-1, 1]) {
    // Yellow kick plate (bottom)
    const kick = new THREE.Mesh(new THREE.BoxGeometry(RW + 2, kickH, bT), kickMat);
    kick.position.set(0, kickH / 2, sz * (RH / 2 + bT / 2)); scene.add(kick);
    // White dasher board (upper)
    const dasher = new THREE.Mesh(new THREE.BoxGeometry(RW + 2, dasherH, bT), dasherMat);
    dasher.position.set(0, kickH + dasherH / 2, sz * (RH / 2 + bT / 2)); scene.add(dasher);
    // Red stripe on dasher
    const stripe = new THREE.Mesh(new THREE.BoxGeometry(RW + 2, 0.3, bT + 0.05), redStripeMat);
    stripe.position.set(0, kickH + dasherH * 0.5, sz * (RH / 2 + bT / 2)); scene.add(stripe);
    // Yellow top cap
    const cap = new THREE.Mesh(new THREE.BoxGeometry(RW + 2, 0.35, bT + 0.4), capMat);
    cap.position.set(0, totalH + 0.17, sz * (RH / 2 + bT / 2)); scene.add(cap);
    // Glass panels above boards
    const glassMat = new THREE.MeshPhysicalMaterial({
      color: 0xffffff, transparent: true, opacity: 0.08,
      roughness: 0, metalness: 0, side: THREE.DoubleSide
    });
    const glass = new THREE.Mesh(new THREE.PlaneGeometry(RW + 2, 6), glassMat);
    glass.position.set(0, totalH + 3, sz * (RH / 2 + bT));
    glass.rotation.y = sz > 0 ? Math.PI : 0; scene.add(glass);
    // Glass support posts
    for (let gp = -90; gp <= 90; gp += 20) {
      const post = new THREE.Mesh(new THREE.BoxGeometry(0.3, 6, 0.2),
        new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.5 }));
      post.position.set(gp, totalH + 3, sz * (RH / 2 + bT / 2)); scene.add(post);
    }
  }
  // End boards (same treatment)
  for (const sx of [-1, 1]) {
    const kick = new THREE.Mesh(new THREE.BoxGeometry(bT, kickH, RH + 2 * bT), kickMat);
    kick.position.set(sx * (RW / 2 + bT / 2), kickH / 2, 0); scene.add(kick);
    const dasher = new THREE.Mesh(new THREE.BoxGeometry(bT, dasherH, RH + 2 * bT), dasherMat);
    dasher.position.set(sx * (RW / 2 + bT / 2), kickH + dasherH / 2, 0); scene.add(dasher);
    const stripe = new THREE.Mesh(new THREE.BoxGeometry(bT + 0.05, 0.3, RH + 2 * bT), redStripeMat);
    stripe.position.set(sx * (RW / 2 + bT / 2), kickH + dasherH * 0.5, 0); scene.add(stripe);
    const cap = new THREE.Mesh(new THREE.BoxGeometry(bT + 0.4, 0.35, RH + 2 * bT + 0.4), capMat);
    cap.position.set(sx * (RW / 2 + bT / 2), totalH + 0.17, 0); scene.add(cap);
  }

  const LY = 0.05;
  function addLine(gx, col, w) {
    const m = new THREE.Mesh(new THREE.PlaneGeometry(w, RH - 4), new THREE.MeshBasicMaterial({ color: col }));
    m.rotation.x = -Math.PI / 2; m.position.set(gx - 100, LY, 0); scene.add(m);
  }
  addLine(CX, 0xcc2222, 1.5); addLine(65, 0x2244cc, 1); addLine(135, 0x2244cc, 1);
  addLine(11, 0xcc2222, 0.5); addLine(189, 0xcc2222, 0.5);

  const rMat = new THREE.MeshBasicMaterial({ color: 0xcc2222, side: THREE.DoubleSide });
  const ring = new THREE.Mesh(new THREE.RingGeometry(14, 15, 40), rMat);
  ring.rotation.x = -Math.PI / 2; ring.position.y = LY; scene.add(ring);
  const dot = new THREE.Mesh(new THREE.CircleGeometry(1.2, 16), new THREE.MeshBasicMaterial({ color: 0xcc2222 }));
  dot.rotation.x = -Math.PI / 2; dot.position.y = LY + 0.01; scene.add(dot);

  for (const [fx, fy] of [[30,20],[30,65],[170,20],[170,65]]) {
    const [tx, tz] = G(fx, fy);
    const r = new THREE.Mesh(new THREE.RingGeometry(9.5, 10.5, 28), rMat.clone());
    r.rotation.x = -Math.PI / 2; r.position.set(tx, LY, tz); scene.add(r);
    const d = new THREE.Mesh(new THREE.CircleGeometry(1, 12), new THREE.MeshBasicMaterial({ color: 0xcc2222 }));
    d.rotation.x = -Math.PI / 2; d.position.set(tx, LY + 0.01, tz); scene.add(d);
  }

  const creaseMat = new THREE.MeshBasicMaterial({ color: 0x4488ff, transparent: true, opacity: 0.2, side: THREE.DoubleSide });
  for (const [gx, rot] of [[11, 0], [189, Math.PI]]) {
    const cm = new THREE.Mesh(new THREE.CircleGeometry(9, 20, -Math.PI / 2, Math.PI), creaseMat);
    cm.rotation.x = -Math.PI / 2; cm.rotation.z = rot;
    cm.position.set(gx - 100, LY + 0.01, 0); scene.add(cm);
  }

  buildGoal(-95); buildGoal(95);
}

function buildGoal(tx) {
  const pm = new THREE.MeshStandardMaterial({ color: 0xcc3333, metalness: 0.6, roughness: 0.3 });
  const nm = new THREE.MeshBasicMaterial({ color: 0xcccccc, transparent: true, opacity: 0.12, side: THREE.DoubleSide, wireframe: true });
  const gW = GOAL_W, gH = 5, gD = 5, pr = 0.25, dir = tx > 0 ? 1 : -1;
  for (const sz of [-1, 1]) {
    const p = new THREE.Mesh(new THREE.CylinderGeometry(pr, pr, gH, 8), pm);
    p.position.set(tx, gH / 2, sz * gW / 2); scene.add(p);
  }
  const bar = new THREE.Mesh(new THREE.CylinderGeometry(pr, pr, gW + 0.5, 8), pm);
  bar.rotation.x = Math.PI / 2; bar.position.set(tx, gH, 0); scene.add(bar);
  const net = new THREE.Mesh(new THREE.BoxGeometry(gD, gH, gW), nm);
  net.position.set(tx + dir * gD / 2, gH / 2, 0); scene.add(net);
}

buildRink();

// ========== PLAYER MESHES ==========
const playerGroups = [];

function createPlayerMesh(team, goalie) {
  const group = new THREE.Group();

  // --- Color palette ---
  const jersey1 = team === 0 ? 0x003da5 : 0xce1126; // primary (Ranger blue / Red Wings red)
  const jersey2 = team === 0 ? 0x0056d6 : 0xe8192c; // lighter accent
  const pantCol = team === 0 ? 0x001d52 : 0x4a0812;
  const helCol  = team === 0 ? 0x003da5 : 0xce1126;
  const gloveCol= team === 0 ? 0x002b80 : 0x8b0a14;
  const skinCol = 0xdbb899;
  const sc = goalie ? 1.12 : 1.0;

  // --- Materials (Standard for realism) ---
  const jerseyMat = new THREE.MeshStandardMaterial({ color: jersey1, roughness: 0.8, metalness: 0 });
  const jersey2Mat= new THREE.MeshStandardMaterial({ color: jersey2, roughness: 0.75 });
  const pantsMat  = new THREE.MeshStandardMaterial({ color: pantCol, roughness: 0.85 });
  const helmetMat = new THREE.MeshStandardMaterial({ color: helCol, roughness: 0.3, metalness: 0.1 });
  const skatesMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.4, metalness: 0.2 });
  const skinMat   = new THREE.MeshStandardMaterial({ color: skinCol, roughness: 0.7 });
  const gloveMat  = new THREE.MeshStandardMaterial({ color: gloveCol, roughness: 0.7 });
  const whiteMat  = new THREE.MeshStandardMaterial({ color: 0xfafafa, roughness: 0.6 });
  const bladeMetal= new THREE.MeshStandardMaterial({ color: 0xcccccc, roughness: 0.15, metalness: 0.9 });
  const cageMat   = new THREE.MeshStandardMaterial({ color: 0xd0d0d0, roughness: 0.2, metalness: 0.6, wireframe: true });
  const darkMat   = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.5 });

  // ===== BODY IN HOCKEY STANCE =====
  // The whole body tilts forward ~15Â° for skating crouch
  const bodyGroup = new THREE.Group();
  bodyGroup.rotation.x = 0.22; // forward lean
  bodyGroup.position.y = 0.1;

  // --- LEGS (bent at knee, separated) ---
  const legGroups = [];
  for (const side of [-1, 1]) {
    const legGroup = new THREE.Group();
    legGroup.position.set(0, 0, side * 0.55 * sc);
    legGroups.push(legGroup);

    // Skate boot
    const boot = new THREE.Mesh(new THREE.BoxGeometry(1.4*sc, 0.6*sc, 0.8*sc), skatesMat);
    boot.position.set(0.15, 0.3, 0);
    legGroup.add(boot);
    // Skate blade
    const bl = new THREE.Mesh(new THREE.BoxGeometry(1.6*sc, 0.05, 0.06), bladeMetal);
    bl.position.set(0.1, 0.02, 0);
    legGroup.add(bl);
    // Ankle
    const ankle = new THREE.Mesh(new THREE.SphereGeometry(0.28*sc, 8, 6), skatesMat);
    ankle.position.set(0, 0.55, 0); legGroup.add(ankle);

    // Shin/calf (angled back â€” bent knee)
    const shin = new THREE.Mesh(new THREE.CylinderGeometry(0.28*sc, 0.32*sc, 1.6*sc, 8), sockMat());
    shin.position.set(-0.15, 1.35, 0);
    shin.rotation.z = 0.2; // angled slightly back
    legGroup.add(shin);
    // Shin pad (white, over sock)
    const shinPad = new THREE.Mesh(new THREE.BoxGeometry(0.35*sc, 1.0*sc, 0.5*sc), whiteMat);
    shinPad.position.set(0.05, 1.3, 0); legGroup.add(shinPad);
    // Sock stripes
    const sockStripe = new THREE.Mesh(new THREE.CylinderGeometry(0.3*sc, 0.3*sc, 0.15, 8), whiteMat);
    sockStripe.position.set(-0.1, 0.9, 0); legGroup.add(sockStripe);
    const sockStripe2 = new THREE.Mesh(new THREE.CylinderGeometry(0.3*sc, 0.3*sc, 0.15, 8), jerseyMat);
    sockStripe2.position.set(-0.1, 1.1, 0); legGroup.add(sockStripe2);

    // Knee
    const knee = new THREE.Mesh(new THREE.SphereGeometry(0.34*sc, 8, 6), pantsMat);
    knee.position.set(-0.25, 2.1, 0); legGroup.add(knee);

    // Thigh (angled forward from hip)
    const thigh = new THREE.Mesh(new THREE.CylinderGeometry(0.38*sc, 0.34*sc, 1.3*sc, 8), pantsMat);
    thigh.position.set(-0.05, 2.75, 0);
    thigh.rotation.z = -0.15;
    legGroup.add(thigh);

    bodyGroup.add(legGroup);
  }

  // Helper for sock material (team colored)
  function sockMat() { return new THREE.MeshStandardMaterial({ color: jersey1, roughness: 0.7 }); }

  // --- WAIST / HOCKEY PANTS ---
  const waist = new THREE.Mesh(new THREE.CylinderGeometry(0.85*sc, 0.95*sc, 1.0, 12), pantsMat);
  waist.position.y = 3.4; bodyGroup.add(waist);
  // Pants shell (slightly bulky â€” protective padding)
  const shell = new THREE.Mesh(
    new THREE.SphereGeometry(0.95*sc, 12, 8, 0, Math.PI * 2, 0, Math.PI * 0.6),
    pantsMat
  );
  shell.position.y = 3.0; shell.rotation.x = Math.PI; bodyGroup.add(shell);

  // --- TORSO / JERSEY ---
  const torso = new THREE.Mesh(new THREE.CylinderGeometry(0.75*sc, 0.9*sc, 2.0, 12), jerseyMat);
  torso.position.y = 4.5; bodyGroup.add(torso);

  // Shoulder pads (rounded, wider than torso)
  const shoulderL = new THREE.Mesh(new THREE.SphereGeometry(0.55*sc, 10, 8), jerseyMat);
  shoulderL.scale.set(1, 0.6, 1);
  shoulderL.position.set(0, 5.4, -1.1*sc); bodyGroup.add(shoulderL);
  const shoulderR = new THREE.Mesh(new THREE.SphereGeometry(0.55*sc, 10, 8), jerseyMat);
  shoulderR.scale.set(1, 0.6, 1);
  shoulderR.position.set(0, 5.4, 1.1*sc); bodyGroup.add(shoulderR);

  // Chest protector bulk (under jersey)
  const chest = new THREE.Mesh(new THREE.SphereGeometry(0.8*sc, 10, 8), jerseyMat);
  chest.scale.set(0.7, 0.5, 1);
  chest.position.set(0.2, 5.0, 0); bodyGroup.add(chest);

  // Jersey stripes (bottom hem, sleeves)
  const hemStripe = new THREE.Mesh(new THREE.CylinderGeometry(0.92*sc, 0.92*sc, 0.15, 12), whiteMat);
  hemStripe.position.y = 3.6; bodyGroup.add(hemStripe);
  const hemStripe2 = new THREE.Mesh(new THREE.CylinderGeometry(0.91*sc, 0.91*sc, 0.1, 12), jersey2Mat);
  hemStripe2.position.y = 3.75; bodyGroup.add(hemStripe2);

  // --- ARMS (in hockey stance â€” hands forward) ---
  for (const side of [-1, 1]) {
    const armGroup = new THREE.Group();
    armGroup.position.set(0, 5.2, side * 1.1 * sc);

    // Upper arm (slight forward + down angle)
    const upper = new THREE.Mesh(new THREE.CylinderGeometry(0.22*sc, 0.28*sc, 1.4, 8), jerseyMat);
    upper.rotation.z = 0.6; // forward
    upper.rotation.x = side * 0.2; // slight outward
    upper.position.set(0.5, -0.5, side * 0.1);
    armGroup.add(upper);

    // Sleeve stripe
    const slvStripe = new THREE.Mesh(new THREE.CylinderGeometry(0.24*sc, 0.24*sc, 0.12, 8), whiteMat);
    slvStripe.rotation.z = 0.6;
    slvStripe.position.set(0.3, -0.3, side * 0.1);
    armGroup.add(slvStripe);

    // Elbow pad
    const elbow = new THREE.Mesh(new THREE.SphereGeometry(0.26*sc, 8, 6),
      new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.6 }));
    elbow.position.set(0.9, -0.9, side * 0.15);
    armGroup.add(elbow);

    // Forearm
    const forearm = new THREE.Mesh(new THREE.CylinderGeometry(0.18*sc, 0.22*sc, 1.0, 8), jerseyMat);
    forearm.rotation.z = 0.9;
    forearm.position.set(1.3, -1.1, side * 0.15);
    armGroup.add(forearm);

    // Glove
    const glove = new THREE.Mesh(new THREE.BoxGeometry(0.55*sc, 0.4*sc, 0.45*sc), gloveMat);
    glove.position.set(1.7, -1.2, side * 0.15);
    // Glove cuff
    const cuff = new THREE.Mesh(new THREE.BoxGeometry(0.4*sc, 0.55*sc, 0.5*sc), gloveMat);
    cuff.position.set(1.5, -1.1, side * 0.15);
    armGroup.add(glove);
    armGroup.add(cuff);

    bodyGroup.add(armGroup);
  }

  // --- NECK & HEAD ---
  const neck = new THREE.Mesh(new THREE.CylinderGeometry(0.22*sc, 0.28*sc, 0.3, 8), skinMat);
  neck.position.y = 5.75; bodyGroup.add(neck);

  // Helmet (proper hockey shape â€” elongated, with back lip)
  const helmetMain = new THREE.Mesh(new THREE.SphereGeometry(0.52*sc, 14, 12), helmetMat);
  helmetMain.scale.set(1.1, 0.95, 1);
  helmetMain.position.y = 6.15; bodyGroup.add(helmetMain);
  // Helmet brim
  const brim = new THREE.Mesh(new THREE.CylinderGeometry(0.55*sc, 0.55*sc, 0.08, 12), helmetMat);
  brim.position.set(0.05, 5.95, 0); bodyGroup.add(brim);
  // Helmet back lip
  const backLip = new THREE.Mesh(new THREE.BoxGeometry(0.3*sc, 0.15, 0.9*sc), helmetMat);
  backLip.position.set(-0.45, 6.0, 0); bodyGroup.add(backLip);

  // Face (small visible skin area)
  const face = new THREE.Mesh(new THREE.PlaneGeometry(0.35*sc, 0.3*sc), skinMat);
  face.position.set(0.48, 6.1, 0); bodyGroup.add(face);

  // Cage (horizontal bars + vertical frame)
  if (!goalie) {
    for (let i = 0; i < 4; i++) {
      const bar = new THREE.Mesh(new THREE.CylinderGeometry(0.015, 0.015, 0.7*sc, 4),
        new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.7, roughness: 0.2 }));
      bar.rotation.x = Math.PI / 2;
      bar.position.set(0.48, 5.95 + i * 0.1, 0);
      bodyGroup.add(bar);
    }
    // Vertical cage bars
    for (const cz of [-0.2, 0, 0.2]) {
      const vbar = new THREE.Mesh(new THREE.CylinderGeometry(0.015, 0.015, 0.4, 4),
        new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.7, roughness: 0.2 }));
      vbar.position.set(0.48, 6.1, cz * sc);
      bodyGroup.add(vbar);
    }
  } else {
    // Goalie mask â€” solid with eye slits
    const mask = new THREE.Mesh(
      new THREE.SphereGeometry(0.48*sc, 10, 8, 0, Math.PI, 0, Math.PI * 0.55),
      new THREE.MeshStandardMaterial({ color: 0xf0f0f0, roughness: 0.3 })
    );
    mask.position.set(0.1, 6.1, 0); mask.rotation.y = -Math.PI / 2; bodyGroup.add(mask);
    // Cage on goalie mask
    for (let i = 0; i < 5; i++) {
      const gb = new THREE.Mesh(new THREE.CylinderGeometry(0.012, 0.012, 0.65*sc, 4), cageMat);
      gb.rotation.x = Math.PI / 2;
      gb.position.set(0.45, 5.9 + i * 0.09, 0);
      bodyGroup.add(gb);
    }
  }

  // Goalie-specific gear
  if (goalie) {
    // Leg pads (big, white, strapped to shins)
    for (const side of [-1, 1]) {
      const pad = new THREE.Mesh(new THREE.BoxGeometry(0.7*sc, 2.6*sc, 1.1*sc),
        new THREE.MeshStandardMaterial({ color: 0xf0f0f0, roughness: 0.5 }));
      pad.position.set(0.2, 1.4, side * 0.55*sc); bodyGroup.add(pad);
      // Pad knee roll
      const roll = new THREE.Mesh(new THREE.CylinderGeometry(0.35*sc, 0.35*sc, 1.1*sc, 8),
        new THREE.MeshStandardMaterial({ color: 0xf0f0f0, roughness: 0.5 }));
      roll.rotation.x = Math.PI / 2;
      roll.position.set(0.2, 2.7, side * 0.55*sc); bodyGroup.add(roll);
    }
    // Blocker (right hand)
    const blocker = new THREE.Mesh(new THREE.BoxGeometry(0.9*sc, 1.1*sc, 0.4*sc),
      new THREE.MeshStandardMaterial({ color: jersey1, roughness: 0.6 }));
    blocker.position.set(1.6, 3.6, 1.2*sc); bodyGroup.add(blocker);
    // Trapper/catcher (left hand)
    const trapper = new THREE.Mesh(new THREE.BoxGeometry(0.5*sc, 0.9*sc, 1.0*sc),
      new THREE.MeshStandardMaterial({ color: jersey1, roughness: 0.6 }));
    trapper.position.set(1.6, 3.6, -1.2*sc); bodyGroup.add(trapper);
    // Chest protector (extra bulk)
    const chestPro = new THREE.Mesh(new THREE.SphereGeometry(0.9*sc, 10, 8), jerseyMat);
    chestPro.scale.set(0.8, 0.6, 1.1);
    chestPro.position.set(0.1, 4.8, 0); bodyGroup.add(chestPro);
  }

  group.add(bodyGroup);

  // === HOCKEY STICK (separate, world-rotated) ===
  const stickGroup = new THREE.Group();
  // Shaft (carbon fiber look)
  const shaft = new THREE.Mesh(
    new THREE.CylinderGeometry(0.07, 0.09, STICK_LEN, 8),
    darkMat
  );
  shaft.rotation.z = Math.PI / 2;
  shaft.position.set(STICK_LEN / 2, 0, 0);
  stickGroup.add(shaft);

  // Grip tape (white, top of shaft)
  const tape = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.1, 2.0, 6), whiteMat);
  tape.rotation.z = Math.PI / 2;
  tape.position.set(0.8, 0, 0);
  stickGroup.add(tape);

  // Blade
  const blade = new THREE.Mesh(
    new THREE.BoxGeometry(2.2, 0.2, 0.55), darkMat
  );
  blade.position.set(STICK_LEN + 0.1, -0.2, 0);
  stickGroup.add(blade);
  // Blade tape (white wrap)
  const bladeTape = new THREE.Mesh(new THREE.BoxGeometry(2.2, 0.22, 0.57), whiteMat);
  bladeTape.position.set(STICK_LEN + 0.1, -0.2, 0);
  stickGroup.add(bladeTape);
  // Blade curve (slight wedge for realism)
  const bCurve = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.2, 0.5), darkMat);
  bCurve.position.set(STICK_LEN + 1.2, -0.25, 0);
  bCurve.rotation.z = -0.3;
  stickGroup.add(bCurve);

  // Blade glow (contact feedback)
  const bladeGlow = new THREE.Mesh(
    new THREE.BoxGeometry(2.6, 0.5, 1.0),
    new THREE.MeshBasicMaterial({ color: 0xffcc00, transparent: true, opacity: 0 })
  );
  bladeGlow.position.set(STICK_LEN + 0.1, -0.1, 0);
  stickGroup.add(bladeGlow);
  group._bladeGlow = bladeGlow;

  stickGroup.position.y = 0.8;
  group.add(stickGroup);
  group._stick = stickGroup;

  // Store animatable references
  group._bodyGroup = bodyGroup;
  group._legs = legGroups; // [left, right]
  group._isGoalie = goalie;
  group._prevFacing = 0; // track facing for rotation

  scene.add(group);
  return group;
}

// Human indicator
const humanIndicator = new THREE.Group();
const ringMat = new THREE.MeshBasicMaterial({ color: 0xffee00, transparent: true, opacity: 0.8 });
const hRing = new THREE.Mesh(new THREE.TorusGeometry(2.2, 0.15, 8, 32), ringMat);
hRing.rotation.x = Math.PI / 2; humanIndicator.add(hRing);
const hArrow = new THREE.Mesh(new THREE.ConeGeometry(0.6, 1.2, 8), new THREE.MeshBasicMaterial({ color: 0xffee00 }));
hArrow.position.y = 1.5; hArrow.rotation.x = Math.PI; humanIndicator.add(hArrow);
scene.add(humanIndicator);

// Puck â€” raised above ice, bigger, brighter glow
const puckMesh = new THREE.Mesh(
  new THREE.CylinderGeometry(PKR, PKR, 0.6, 16),
  new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.3, metalness: 0.3 })
);
puckMesh.castShadow = true;
scene.add(puckMesh);
const puckGlow = new THREE.Mesh(
  new THREE.TorusGeometry(PKR * 1.4, 0.15, 8, 28),
  new THREE.MeshBasicMaterial({ color: 0xffcc00, transparent: true, opacity: 0.7 })
);
puckGlow.rotation.x = Math.PI / 2; scene.add(puckGlow);
// Puck spotlight (always lights the puck area)
const puckLight = new THREE.PointLight(0xffdd44, 0.8, 20, 2);
scene.add(puckLight);

// ========== GAME STATE ==========
let state = 'menu', score = [0, 0], period = 1, clock = PERIOD_SECS;
let goalTimer = 0, faceoffTimer = 0;
let players = [], puck = { x: CX, y: CY, vx: 0, vy: 0 };
const humanIdx = 1;

function makeTeams() {
  players = []; playerGroups.forEach(g => scene.remove(g)); playerGroups.length = 0;
  const defs = [
    { x: 10, y: CY, team: 0, goalie: true },
    { x: 60, y: CY, team: 0, goalie: false },
    { x: 45, y: CY - 22, team: 0, goalie: false },
    { x: 45, y: CY + 22, team: 0, goalie: false },
    { x: 190, y: CY, team: 1, goalie: true },
    { x: 140, y: CY, team: 1, goalie: false },
    { x: 155, y: CY - 22, team: 1, goalie: false },
    { x: 155, y: CY + 22, team: 1, goalie: false },
  ];
  for (const d of defs) {
    const defAngle = d.team === 0 ? 0 : Math.PI;
    players.push({ ...d, vx: 0, vy: 0, stickAngle: defAngle, prevStickAngle: defAngle, _wasTouching: false });
    playerGroups.push(createPlayerMesh(d.team, d.goalie));
  }
}

function faceoff() {
  puck.x = CX; puck.y = CY; puck.vx = 0; puck.vy = 0;
  const pos = [[10,CY],[95,CY],[80,CY-22],[80,CY+22],[190,CY],[105,CY],[120,CY-22],[120,CY+22]];
  for (let i = 0; i < players.length; i++) {
    players[i].x = pos[i][0]; players[i].y = pos[i][1];
    players[i].vx = 0; players[i].vy = 0;
    players[i].stickAngle = players[i].team === 0 ? 0 : Math.PI;
    players[i].prevStickAngle = players[i].stickAngle;
    players[i]._wasTouching = false;
  }
  faceoffTimer = 1.5; state = 'faceoff';
  // Snap camera to face the puck from behind player
  const [htx, htz] = G(players[humanIdx].x, players[humanIdx].y);
  const [ptx, ptz] = G(puck.x, puck.y);
  camFacingAngle = Math.atan2(ptz - htz, ptx - htx);
  camCur.x = htx - Math.cos(camFacingAngle) * CAM_BACK;
  camCur.z = htz - Math.sin(camFacingAngle) * CAM_BACK;
  faceoffEl.textContent = 'FACE OFF'; faceoffEl.style.display = 'block';
}

// ========== INPUT ==========
let moveF = 0, moveS = 0;
let stickAimX = 0, stickAimY = 0; // right stick: x=horizontal, y=vertical (-1=up)
let stickActive = false;
let keys = {};
document.addEventListener('keydown', e => { keys[e.code] = true; });
document.addEventListener('keyup', e => { keys[e.code] = false; });

function readKeys() {
  if (isMobile) return;
  let f = 0, s = 0;
  if (keys['KeyW']) f += 1; if (keys['KeyS']) f -= 1;
  if (keys['KeyA']) s -= 1; if (keys['KeyD']) s += 1;
  const m = Math.hypot(f, s); if (m > 1) { f /= m; s /= m; }
  moveF = f; moveS = s;

  // Arrow keys for stick
  let sx = 0, sy = 0;
  if (keys['ArrowUp']) sy -= 1; if (keys['ArrowDown']) sy += 1;
  if (keys['ArrowLeft']) sx -= 1; if (keys['ArrowRight']) sx += 1;
  const sm = Math.hypot(sx, sy);
  if (sm > 0.1) {
    stickAimX = sx / sm; stickAimY = sy / sm;
    stickActive = true;
  } else {
    stickActive = false;
  }
}

// Touch â€” dual analog sticks
let lJoyTouchId = null, lJoyActive = false, lJoyCX = 0, lJoyCY = 0, lJoyDX = 0, lJoyDY = 0;
let rJoyTouchId = null, rJoyActive = false, rJoyCX = 0, rJoyCY = 0, rJoyDX = 0, rJoyDY = 0;
const JOY_R = 55;
const lBase = document.getElementById('lJoyBase'), lKnob = document.getElementById('lJoyKnob');
const rBase = document.getElementById('rJoyBase'), rKnob = document.getElementById('rJoyKnob');

function showJoy(base, knob, cx, cy) {
  base.style.display = 'block'; knob.style.display = 'block';
  base.style.left = (cx - 55) + 'px'; base.style.top = (cy - 55) + 'px';
  knob.style.left = (cx - 23) + 'px'; knob.style.top = (cy - 23) + 'px';
}
function moveJoyKnob(knob, cx, cy, dx, dy) {
  knob.style.left = (cx + dx - 23) + 'px'; knob.style.top = (cy + dy - 23) + 'px';
}
function hideJoy(base, knob) { base.style.display = 'none'; knob.style.display = 'none'; }

document.addEventListener('touchstart', e => {
  e.preventDefault();
  for (const t of e.changedTouches) {
    const tx = t.clientX, ty = t.clientY;
    if (tx < W * 0.45 && lJoyTouchId === null) {
      lJoyTouchId = t.identifier; lJoyActive = true; lJoyCX = tx; lJoyCY = ty; lJoyDX = 0; lJoyDY = 0;
      showJoy(lBase, lKnob, tx, ty);
    } else if (tx >= W * 0.45 && rJoyTouchId === null) {
      rJoyTouchId = t.identifier; rJoyActive = true; rJoyCX = tx; rJoyCY = ty; rJoyDX = 0; rJoyDY = 0;
      showJoy(rBase, rKnob, tx, ty);
    }
  }
}, { passive: false });

document.addEventListener('touchmove', e => {
  e.preventDefault();
  for (const t of e.changedTouches) {
    if (t.identifier === lJoyTouchId) {
      let dx = t.clientX - lJoyCX, dy = t.clientY - lJoyCY;
      const d = Math.hypot(dx, dy); if (d > JOY_R) { dx *= JOY_R / d; dy *= JOY_R / d; }
      lJoyDX = dx; lJoyDY = dy;
      moveF = -dy / JOY_R; moveS = dx / JOY_R;
      moveJoyKnob(lKnob, lJoyCX, lJoyCY, dx, dy);
    }
    if (t.identifier === rJoyTouchId) {
      let dx = t.clientX - rJoyCX, dy = t.clientY - rJoyCY;
      const d = Math.hypot(dx, dy); if (d > JOY_R) { dx *= JOY_R / d; dy *= JOY_R / d; }
      rJoyDX = dx; rJoyDY = dy;
      const rm = Math.hypot(dx, dy);
      if (rm > 8) {
        stickAimX = dx / rm; stickAimY = dy / rm;
        stickActive = true;
      }
      moveJoyKnob(rKnob, rJoyCX, rJoyCY, dx, dy);
    }
  }
}, { passive: false });

document.addEventListener('touchend', e => {
  for (const t of e.changedTouches) {
    if (t.identifier === lJoyTouchId) {
      lJoyTouchId = null; lJoyActive = false; moveF = 0; moveS = 0;
      hideJoy(lBase, lKnob);
    }
    if (t.identifier === rJoyTouchId) {
      rJoyTouchId = null; rJoyActive = false; stickActive = false;
      hideJoy(rBase, rKnob);
    }
  }
});
document.addEventListener('touchcancel', () => {
  lJoyTouchId = null; lJoyActive = false; moveF = 0; moveS = 0; hideJoy(lBase, lKnob);
  rJoyTouchId = null; rJoyActive = false; stickActive = false; hideJoy(rBase, rKnob);
});

// ========== AUDIO ==========
let ac = null;
function ensureAudio() { if (!ac) try { ac = new (window.AudioContext || window.webkitAudioContext)(); } catch (e) {} }
function beep(f, d, t, v) { if (!ac) return; try { const o = ac.createOscillator(), g = ac.createGain(); o.type = t || 'square'; o.frequency.value = f; g.gain.setValueAtTime(v || 0.1, ac.currentTime); g.gain.exponentialRampToValueAtTime(0.001, ac.currentTime + d); o.connect(g); g.connect(ac.destination); o.start(); o.stop(ac.currentTime + d); } catch (e) {} }
function sndShot() { beep(600, 0.08, 'square', 0.12); }
function sndHit() { beep(300, 0.04, 'square', 0.08); }
function sndGoal() { beep(200, 1.5, 'sawtooth', 0.25); setTimeout(() => beep(250, 1, 'sawtooth', 0.2), 150); }
function sndWhistle() { beep(800, 0.3, 'sine', 0.12); }

// ========== HELPERS ==========
function dist(a, b) { return Math.hypot(a.x - b.x, a.y - b.y); }
function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }
function angleDiff(a, b) { let d = a - b; while (d > Math.PI) d -= 2 * Math.PI; while (d < -Math.PI) d += 2 * Math.PI; return d; }

// ========== AI ==========
function aiStickTarget(p, idx) {
  const bladeTipX = p.x + Math.cos(p.stickAngle) * STICK_LEN;
  const bladeTipY = p.y + Math.sin(p.stickAngle) * STICK_LEN;
  const dPuck = dist(p, puck);
  const bladePuck = Math.hypot(bladeTipX - puck.x, bladeTipY - puck.y);

  // If blade is touching puck â€” aim toward goal
  if (bladePuck < CONTACT_R + 2) {
    const goalX = p.team === 0 ? 198 : 2;
    // Add some randomness to make AI less robotic
    const targetY = CY + (Math.random() - 0.5) * GOAL_W * 0.6;
    return Math.atan2(targetY - p.y, goalX - p.x);
  }

  // If close to puck â€” reach for it
  if (dPuck < STICK_LEN + 5) {
    return Math.atan2(puck.y - p.y, puck.x - p.x);
  }

  // Default: point forward
  return p.team === 0 ? 0 : Math.PI;
}

function updateAI(p, idx, dt) {
  // Movement AI (same as before)
  if (p.goalie) {
    const gx = p.team === 0 ? 8 : 192;
    const ty = clamp(puck.y, CY - 18, CY + 18);
    p.vy += (ty - p.y) * 6 * dt; p.vx += (gx - p.x) * 6 * dt;
    // Goalie stick: always aim at puck
    p._stickTarget = Math.atan2(puck.y - p.y, puck.x - p.x);
    return;
  }

  const dPuck = dist(p, puck);

  // Decide movement based on team situation
  const closestOnTeam = () => {
    let best = true;
    for (let j = 0; j < players.length; j++) {
      const o = players[j];
      if (o === p || o.team !== p.team || o.goalie) continue;
      if (dist(o, puck) < dPuck - 3) { best = false; break; }
    }
    return best;
  };

  const isClosest = closestOnTeam();

  if (isClosest && dPuck < 40) {
    // Chase puck
    const a = Math.atan2(puck.y - p.y, puck.x - p.x);
    p.vx += Math.cos(a) * ACCEL * 0.6 * dt;
    p.vy += Math.sin(a) * ACCEL * 0.6 * dt;
  } else if (isClosest) {
    // Move toward puck zone
    const a = Math.atan2(puck.y - p.y, puck.x - p.x);
    p.vx += Math.cos(a) * ACCEL * 0.45 * dt;
    p.vy += Math.sin(a) * ACCEL * 0.45 * dt;
  } else {
    // Get open / cover lane
    const offX = p.team === 0
      ? clamp(puck.x + 20 + (idx % 3) * 10, 30, 175)
      : clamp(puck.x - 20 - (idx % 3) * 10, 25, 170);
    const laneY = idx % 2 === 0 ? CY - 22 : CY + 22;
    const a = Math.atan2(laneY - p.y, offX - p.x);
    p.vx += Math.cos(a) * ACCEL * 0.35 * dt;
    p.vy += Math.sin(a) * ACCEL * 0.35 * dt;
  }

  // Stick AI
  p._stickTarget = aiStickTarget(p, idx);
}

// ========== STICK-PUCK PHYSICS ==========
function updateStickPuck(p, dt) {
  const bladeTipX = p.x + Math.cos(p.stickAngle) * STICK_LEN;
  const bladeTipY = p.y + Math.sin(p.stickAngle) * STICK_LEN;
  const prevBX = (p.x - p.vx * dt) + Math.cos(p.prevStickAngle) * STICK_LEN;
  const prevBY = (p.y - p.vy * dt) + Math.sin(p.prevStickAngle) * STICK_LEN;

  const bladeDist = Math.hypot(bladeTipX - puck.x, bladeTipY - puck.y);
  const touching = bladeDist < CONTACT_R;

  if (touching) {
    // Calculate blade tip velocity
    const bvx = (bladeTipX - prevBX) / Math.max(dt, 0.001);
    const bvy = (bladeTipY - prevBY) / Math.max(dt, 0.001);
    const tipSpeed = Math.hypot(bvx, bvy);

    if (!p._wasTouching && tipSpeed > 20) {
      // IMPACT â€” first contact with moving blade
      const power = clamp(tipSpeed * STICK_POWER, 40, SHOT_SPD);
      const hitAngle = Math.atan2(bvy, bvx);
      puck.vx = Math.cos(hitAngle) * power;
      puck.vy = Math.sin(hitAngle) * power;
      if (power > 150) sndShot();
      else sndHit();
      p._bladeFlash = 0.3;
    } else if (tipSpeed > 10) {
      // CARRY â€” ongoing contact, gentle push in stick direction
      puck.vx += Math.cos(p.stickAngle) * CARRY_FORCE * dt;
      puck.vy += Math.sin(p.stickAngle) * CARRY_FORCE * dt;
    }
  }
  p._wasTouching = touching;
}

// ========== UPDATE ==========
const faceoffEl = document.getElementById('faceoffText');

function update(dt) {
  if (state === 'faceoff') {
    faceoffTimer -= dt;
    if (faceoffTimer < 0.8) faceoffEl.textContent = 'GO!';
    if (faceoffTimer <= 0) { state = 'playing'; faceoffEl.style.display = 'none'; sndWhistle(); }
    return;
  }
  if (state !== 'playing') return;
  clock -= dt; if (clock <= 0) { clock = 0; endPeriod(); return; }

  readKeys();

  // Human movement â€” relative to camera facing direction
  const human = players[humanIdx];
  // Camera faces camFacingAngle in Three.js XZ, which maps directly to game XY
  const cf = camFacingAngle;
  const worldMoveX = moveF * Math.cos(cf) - moveS * Math.sin(cf);
  const worldMoveY = moveF * Math.sin(cf) + moveS * Math.cos(cf);
  human.vx += worldMoveX * ACCEL * dt;
  human.vy += worldMoveY * ACCEL * dt;

  // Human stick control â€” also camera-relative
  if (stickActive) {
    // Right stick: up = toward puck (camera forward), right = camera right
    const localAngle = Math.atan2(stickAimX, -stickAimY);
    human._stickTarget = cf + localAngle;
  } else {
    // Default: stick points toward puck
    human._stickTarget = Math.atan2(puck.y - human.y, puck.x - human.x);
  }

  // AI movement + stick targets
  for (let i = 0; i < players.length; i++) {
    if (i === humanIdx) continue;
    updateAI(players[i], i, dt);
  }

  // Update all stick angles (smooth rotation toward target)
  for (const p of players) {
    p.prevStickAngle = p.stickAngle;
    const target = p._stickTarget !== undefined ? p._stickTarget : (p.team === 0 ? 0 : Math.PI);
    const diff = angleDiff(target, p.stickAngle);
    const rotSpeed = 14; // radians/sec â€” fast but not instant
    p.stickAngle += clamp(diff, -rotSpeed * dt, rotSpeed * dt);
  }

  // Player physics
  for (let p of players) {
    p.vx *= Math.pow(FRICTION, dt * 60);
    p.vy *= Math.pow(FRICTION, dt * 60);
    const spd = Math.hypot(p.vx, p.vy);
    if (spd > MAX_SPD) { p.vx *= MAX_SPD / spd; p.vy *= MAX_SPD / spd; }
    p.x += p.vx * dt; p.y += p.vy * dt;
    const r = p.goalie ? GR : PR;
    p.x = clamp(p.x, r, RW - r); p.y = clamp(p.y, r, RH - r);
  }

  // Puck physics
  puck.vx *= Math.pow(0.984, dt * 60);
  puck.vy *= Math.pow(0.984, dt * 60);
  puck.x += puck.vx * dt;
  puck.y += puck.vy * dt;

  // Board bounces
  if (puck.y < PKR) { puck.y = PKR; puck.vy *= -0.6; }
  if (puck.y > RH - PKR) { puck.y = RH - PKR; puck.vy *= -0.6; }

  // End board bounces / goals
  if (puck.x < 4) {
    if (Math.abs(puck.y - CY) < GOAL_W / 2) { doGoal(1); return; }
    else { puck.vx *= -0.6; puck.x = 4; }
  }
  if (puck.x > RW - 4) {
    if (Math.abs(puck.y - CY) < GOAL_W / 2) { doGoal(0); return; }
    else { puck.vx *= -0.6; puck.x = RW - 4; }
  }

  // Goalie body blocks (simple: puck bounces off goalie body)
  for (const p of players) {
    if (!p.goalie) continue;
    const d = dist(p, puck);
    if (d < GR + PKR + 1 && d > 0.1) {
      const nx = (puck.x - p.x) / d, ny = (puck.y - p.y) / d;
      puck.vx = Math.abs(Math.hypot(puck.vx, puck.vy)) * nx * 0.4 + nx * 25;
      puck.vy = ny * 25;
      puck.x = p.x + nx * (GR + PKR + 1.5);
      puck.y = p.y + ny * (GR + PKR + 1.5);
      sndHit();
    }
  }

  // Stick-puck collisions for all players
  for (const p of players) {
    updateStickPuck(p, dt);
  }

  // Player-player collisions
  for (let i = 0; i < players.length; i++) {
    for (let j = i + 1; j < players.length; j++) {
      const a = players[i], b = players[j], d = dist(a, b);
      const minD = (a.goalie ? GR : PR) + (b.goalie ? GR : PR);
      if (d < minD && d > 0.1) {
        const nx = (b.x - a.x) / d, ny = (b.y - a.y) / d, ov = (minD - d) / 2;
        a.x -= nx * ov; a.y -= ny * ov; b.x += nx * ov; b.y += ny * ov;
        const dv = (a.vx - b.vx) * nx + (a.vy - b.vy) * ny;
        a.vx -= dv * 0.4 * nx; a.vy -= dv * 0.4 * ny;
        b.vx += dv * 0.4 * nx; b.vy += dv * 0.4 * ny;
      }
    }
  }
}

function doGoal(team) {
  score[team]++; state = 'goal'; goalTimer = 2.5; sndGoal();
  document.getElementById('goalFlash').style.display = 'flex';
}
function endPeriod() {
  sndWhistle();
  if (period >= 3 && score[0] !== score[1]) {
    state = 'over';
    document.getElementById('winText').textContent = score[0] > score[1] ? 'ðŸ”µ BLUE WINS!' : 'ðŸ”´ RED WINS!';
    document.getElementById('gameOverlay').style.display = 'flex';
  } else { period++; clock = PERIOD_SECS; faceoff(); }
}

// ========== CAMERA ==========
const CAM_BACK = 20, CAM_UP = 13;
const camCur = { x: 0, y: CAM_UP, z: 0 };
const SMOOTH = 0.1;
let camFacingAngle = 0; // smoothed angle from player toward puck (in Three.js XZ)

function updateCamera() {
  const h = players[humanIdx];
  const [hx, hz] = G(h.x, h.y);
  const [px, pz] = G(puck.x, puck.y);

  // Target angle: from player toward puck
  const targetAngle = Math.atan2(pz - hz, px - hx);
  // Smooth the camera rotation (avoid whiplash when puck flips sides)
  const aDiff = angleDiff(targetAngle, camFacingAngle);
  camFacingAngle += aDiff * 0.05; // slow smooth orbit

  // Camera behind player (opposite direction from puck)
  const tgtX = hx - Math.cos(camFacingAngle) * CAM_BACK;
  const tgtZ = hz - Math.sin(camFacingAngle) * CAM_BACK;
  camCur.x += (tgtX - camCur.x) * SMOOTH;
  camCur.z += (tgtZ - camCur.z) * SMOOTH;

  camera.position.set(camCur.x, CAM_UP, camCur.z);
  // Look past the player toward the puck
  const lookX = hx + Math.cos(camFacingAngle) * 10;
  const lookZ = hz + Math.sin(camFacingAngle) * 10;
  camera.lookAt(lookX, 1, lookZ);
}

// ========== SYNC 3D ==========
function sync3D(t) {
  for (let i = 0; i < players.length; i++) {
    const p = players[i], g = playerGroups[i];
    if (!g) continue;
    const [tx, tz] = G(p.x, p.y);
    g.position.set(tx, 0, tz);

    const spd = Math.hypot(p.vx, p.vy);
    const moveAngle = Math.atan2(p.vy, p.vx); // game-world movement direction

    // ---- BODY ROTATION: face movement direction ----
    if (spd > 3) {
      // In Three.js, rotation.y = 0 means facing +x.
      // Game angle 0 = +x, game angle Ï€/2 = +y = Three.js +z
      // Three.js y-rotation: positive = CCW from above, so -moveAngle
      const targetFacing = -moveAngle;
      const faceDiff = angleDiff(targetFacing, g._prevFacing || 0);
      g._prevFacing = (g._prevFacing || 0) + faceDiff * 0.15; // smooth turn
      g.rotation.y = g._prevFacing;
    }

    // ---- SKATING STRIDE (legs) ----
    if (g._legs && g._legs.length === 2) {
      const strideFreq = 8 + spd * 0.12; // faster skating = faster stride
      const strideAmp = clamp(spd / MAX_SPD, 0, 1) * 0.6; // bigger strides when faster
      if (spd > 3) {
        // Alternate legs: swing forward/back around the hip (rotation around X in leg-local space)
        g._legs[0].rotation.x = Math.sin(t * strideFreq) * strideAmp;
        g._legs[1].rotation.x = Math.sin(t * strideFreq + Math.PI) * strideAmp; // opposite phase
        // Slight lateral push (skating crossover feel)
        g._legs[0].position.z = -0.55 + Math.sin(t * strideFreq * 0.5) * 0.08;
        g._legs[1].position.z = 0.55 + Math.sin(t * strideFreq * 0.5 + Math.PI) * 0.08;
      } else {
        // Idle: subtle weight shift
        g._legs[0].rotation.x = Math.sin(t * 1.5) * 0.03;
        g._legs[1].rotation.x = Math.sin(t * 1.5 + Math.PI) * 0.03;
        g._legs[0].position.z = -0.55;
        g._legs[1].position.z = 0.55;
      }
    }

    // ---- BODY LEAN into turns + skating bob ----
    if (g._bodyGroup) {
      // Forward lean increases with speed
      const leanFwd = 0.22 + clamp(spd / MAX_SPD, 0, 1) * 0.12;
      g._bodyGroup.rotation.x = leanFwd;

      // Lean into turns (body tilts sideways)
      // Use angular velocity of facing as proxy for turning
      const turnRate = angleDiff(-moveAngle, g._prevFacing || 0);
      const leanSide = clamp(turnRate * 0.3, -0.15, 0.15);
      g._bodyGroup.rotation.z = leanSide * (spd > 5 ? 1 : 0);

      // Skating bob (up/down with stride)
      if (spd > 5) {
        const bob = Math.abs(Math.sin(t * (8 + spd * 0.12) * 2)) * 0.15 * clamp(spd / MAX_SPD, 0, 1);
        g._bodyGroup.position.y = 0.1 + bob;
      } else {
        // Idle breathing
        g._bodyGroup.position.y = 0.1 + Math.sin(t * 2) * 0.02;
      }
    }

    // ---- STICK ROTATION (world-space, compensate for body rotation) ----
    if (g._stick) {
      // Stick needs to be in world angle, but it's a child of the group which rotates
      // So subtract the group's y-rotation to keep stick in world space
      g._stick.rotation.y = -p.stickAngle - (g._prevFacing || 0);
    }

    // ---- BLADE FLASH on contact ----
    if (g._bladeGlow) {
      if (p._bladeFlash > 0) {
        g._bladeGlow.material.opacity = p._bladeFlash * 2;
        p._bladeFlash -= 0.016;
      } else {
        g._bladeGlow.material.opacity = 0;
      }
    }
  }

  // Human indicator
  const h = players[humanIdx], [hx, hz] = G(h.x, h.y);
  humanIndicator.position.set(hx, 7.5, hz); // raised for taller players
  ringMat.opacity = 0.6 + 0.4 * Math.sin(t * 5);
  hArrow.position.y = 1.2 + Math.sin(t * 4) * 0.3;

  // Puck â€” always visible, raised well above ice
  const [px, pz] = G(puck.x, puck.y);
  puckMesh.position.set(px, 0.5, pz);
  puckMesh.visible = true;
  puckGlow.position.set(px, 0.6, pz);
  puckGlow.visible = true;
  puckGlow.material.opacity = 0.4 + 0.4 * Math.sin(t * 8);
  // Puck spotlight
  puckLight.position.set(px, 5, pz);

  // Puck spin based on velocity
  const puckSpd = Math.hypot(puck.vx, puck.vy);
  if (puckSpd > 5) {
    puckMesh.rotation.y += puckSpd * 0.01;
  }
}

// ========== MINIMAP ==========
const mmCanvas = document.getElementById('minimap');
const mmCtx = mmCanvas.getContext('2d');
const mmW = 140, mmH = 60;

function drawMinimap() {
  const s = mmW / RW;
  mmCtx.clearRect(0, 0, mmW, mmH);
  mmCtx.fillStyle = 'rgba(0,0,0,0.6)'; mmCtx.fillRect(0, 0, mmW, mmH);
  mmCtx.fillStyle = 'rgba(200,210,220,0.15)'; mmCtx.fillRect(1, 1, mmW - 2, mmH - 2);
  mmCtx.strokeStyle = 'rgba(200,40,40,0.4)'; mmCtx.lineWidth = 1;
  mmCtx.beginPath(); mmCtx.moveTo(CX * s, 0); mmCtx.lineTo(CX * s, mmH); mmCtx.stroke();
  mmCtx.strokeStyle = 'rgba(40,60,200,0.3)';
  mmCtx.beginPath(); mmCtx.moveTo(65 * s, 0); mmCtx.lineTo(65 * s, mmH); mmCtx.stroke();
  mmCtx.beginPath(); mmCtx.moveTo(135 * s, 0); mmCtx.lineTo(135 * s, mmH); mmCtx.stroke();
  for (let i = 0; i < players.length; i++) {
    const p = players[i];
    mmCtx.fillStyle = p.team === 0 ? '#4af' : '#f44';
    mmCtx.beginPath(); mmCtx.arc(p.x * s, p.y * (mmH / RH), i === humanIdx ? 3.5 : 2, 0, Math.PI * 2); mmCtx.fill();
    if (i === humanIdx) { mmCtx.strokeStyle = '#ffee00'; mmCtx.lineWidth = 1; mmCtx.stroke(); }
    // Draw stick on minimap
    const bx = p.x + Math.cos(p.stickAngle) * STICK_LEN * 0.5;
    const by = p.y + Math.sin(p.stickAngle) * STICK_LEN * 0.5;
    mmCtx.strokeStyle = p.team === 0 ? '#8cf' : '#f88'; mmCtx.lineWidth = 0.5;
    mmCtx.beginPath(); mmCtx.moveTo(p.x * s, p.y * (mmH / RH)); mmCtx.lineTo(bx * s, by * (mmH / RH)); mmCtx.stroke();
  }
  mmCtx.fillStyle = '#ff0'; mmCtx.beginPath();
  mmCtx.arc(puck.x * s, puck.y * (mmH / RH), 2, 0, Math.PI * 2); mmCtx.fill();
}

// ========== HUD ==========
function updateHUD() {
  document.getElementById('sBlue').textContent = score[0];
  document.getElementById('sRed').textContent = score[1];
  const m = Math.floor(clock / 60), s = Math.floor(clock % 60);
  document.getElementById('sTime').textContent = m + ':' + String(s).padStart(2, '0');
  document.getElementById('sPer').textContent = period > 3 ? 'OT' : period;
}

// ========== GAME LOOP ==========
const clock3d = new THREE.Clock();

function animate() {
  requestAnimationFrame(animate);
  const dt = Math.min(clock3d.getDelta(), 0.05);
  const t = clock3d.getElapsedTime();

  if (state === 'goal') {
    goalTimer -= dt;
    updateCamera(); // keep camera orbiting during goal
    if (goalTimer <= 0) { document.getElementById('goalFlash').style.display = 'none'; faceoff(); }
  } else {
    update(dt);
  }

  updateCamera();
  sync3D(t);
  drawMinimap();
  updateHUD();
  renderer.render(scene, camera);
}

// ========== START ==========
function startGame() {
  document.getElementById('startScreen').style.display = 'none';
  document.getElementById('hud').style.display = 'block';
  document.getElementById('minimap').style.display = 'block';
  document.getElementById('gameOverlay').style.display = 'none';
  if (!isMobile) document.getElementById('controlHint').style.display = 'block';
  ensureAudio(); if (ac) ac.resume();
  score = [0, 0]; period = 1; clock = PERIOD_SECS;
  makeTeams(); faceoff();
}

document.getElementById('playBtn').addEventListener('click', e => { e.stopPropagation(); startGame(); });
document.getElementById('playBtn').addEventListener('touchend', e => { e.preventDefault(); startGame(); });
document.addEventListener('click', () => { if (state === 'over') startGame(); });
document.addEventListener('touchend', () => { if (state === 'over') startGame(); });

animate();
</script>
</body>
</html>
