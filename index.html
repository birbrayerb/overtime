<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
<title>OVERTIME - 3v3 Hockey</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
body{background:#111;overflow:hidden;font-family:'Segoe UI',Arial,sans-serif;-webkit-user-select:none;user-select:none}
canvas{display:block;position:absolute;top:0;left:0}

#startScreen{position:fixed;inset:0;z-index:200;background:linear-gradient(135deg,#0a1628 0%,#1a3a5c 50%,#0a1628 100%);display:flex;flex-direction:column;align-items:center;justify-content:center}
#startScreen h1{font-size:min(18vw,100px);color:#fff;text-shadow:0 0 40px #4af,0 0 80px #28f;letter-spacing:8px;margin-bottom:8px;font-weight:900}
#startScreen .sub{color:#8cf;font-size:min(5vw,20px);margin-bottom:40px;letter-spacing:4px}
#playBtn{font-size:min(7vw,32px);padding:18px 60px;background:linear-gradient(180deg,#e33,#b00);color:#fff;border:none;border-radius:50px;cursor:pointer;letter-spacing:3px;font-weight:700;touch-action:manipulation;-webkit-tap-highlight-color:transparent;box-shadow:0 4px 20px rgba(255,0,0,0.4)}

#hud{position:fixed;top:10px;left:50%;transform:translateX(-50%);z-index:50;background:rgba(0,0,0,0.8);border-radius:12px;padding:8px 24px;color:#fff;text-align:center;display:none}
#hud .score{font-size:28px;font-weight:bold}
#hud .score .blue{color:#4af}
#hud .score .red{color:#f44}
#hud .info{font-size:13px;color:#888}

#controls{position:fixed;bottom:0;left:0;right:0;z-index:50;display:none;pointer-events:none;height:200px}
#joyZone{position:absolute;left:0;bottom:0;width:50%;height:100%;pointer-events:auto;touch-action:none}
#joyBase{position:absolute;width:120px;height:120px;border-radius:50%;border:3px solid rgba(255,255,255,0.2);background:rgba(255,255,255,0.05);display:none;pointer-events:none}
#joyKnob{position:absolute;width:50px;height:50px;border-radius:50%;background:rgba(255,255,255,0.4);display:none;pointer-events:none}
#btnZone{position:absolute;right:20px;bottom:30px;pointer-events:auto;display:flex;flex-direction:column;gap:12px}
#btnZone button{width:72px;height:72px;border-radius:50%;border:2px solid rgba(255,255,255,0.4);font-size:12px;font-weight:bold;color:#fff;touch-action:manipulation;-webkit-tap-highlight-color:transparent}
#btnShoot{background:rgba(220,40,40,0.5)}
#btnPass{background:rgba(40,120,220,0.5)}

#goalFlash{position:fixed;inset:0;z-index:100;display:none;align-items:center;justify-content:center;pointer-events:none;background:rgba(255,0,0,0.15)}
#goalFlash span{font-size:min(15vw,80px);font-weight:900;color:#fff;text-shadow:0 0 40px red}
</style>
</head>
<body>

<div id="startScreen">
  <h1>OVERTIME</h1>
  <div class="sub">3 v 3 HOCKEY</div>
  <button id="playBtn">â–¶ PLAY</button>
</div>

<canvas id="c"></canvas>

<div id="hud">
  <div class="score"><span class="blue" id="sBlue">0</span> â€” <span class="red" id="sRed">0</span></div>
  <div class="info">P<span id="sPer">1</span> Â· <span id="sTime">2:00</span></div>
</div>

<div id="controls">
  <div id="joyZone"></div>
  <div id="joyBase"></div>
  <div id="joyKnob"></div>
  <div id="btnZone">
    <button id="btnShoot">SHOOT</button>
    <button id="btnPass">PASS</button>
  </div>
</div>

<div id="goalFlash"><span>ðŸš¨ GOAL!</span></div>

<script>
const C = document.getElementById('c');
const ctx = C.getContext('2d');

// ---- Sizing ----
let W, H, rX, rY, rW, rH, S;
function resize() {
  W = C.width = window.innerWidth;
  H = C.height = window.innerHeight;
  // Fit rink (200x85 units) with padding
  const aspect = 200/85;
  const pad = 20;
  const availW = W - pad*2, availH = H - pad*2 - 50;
  if (availW / availH > aspect) { rH = availH; rW = rH * aspect; }
  else { rW = availW; rH = rW / aspect; }
  rX = (W - rW) / 2;
  rY = (H - rH) / 2 + 25;
  S = rW / 200;
}
window.addEventListener('resize', resize);
resize();

// ---- Coordinate helpers ----
function wx(x) { return rX + x * S; }
function wy(y) { return rY + y * S; }
function ws(s) { return s * S; }

// ---- Constants ----
const RW = 200, RH = 85, CX = 100, CY = 42.5;
const PERIOD_SECS = 120;
const PR = 3.5; // player radius
const PKR = 1.2; // puck radius
const GR = 4; // goalie radius
const GOAL_W = 12; // goal width
const ACCEL = 250;
const FRICTION = 0.92;
const MAX_SPD = 90;
const SHOT_SPD = 250;
const PASS_SPD = 180;

// ---- State ----
let state = 'menu'; // menu, playing, faceoff, goal, periodEnd, over
let score = [0, 0];
let period = 1;
let clock = PERIOD_SECS;
let goalTimer = 0;
let faceoffTimer = 0;
let particles = [];

// ---- Entities ----
let players = [];
let puck = { x: CX, y: CY, vx: 0, vy: 0, owner: null };

function makeTeams() {
  players = [];
  // Blue team (left side, attacks right toward x=200)
  players.push({ x:10, y:CY, vx:0, vy:0, team:0, goalie:true }); // 0: goalie
  players.push({ x:60, y:CY, vx:0, vy:0, team:0, goalie:false }); // 1: center (HUMAN)
  players.push({ x:45, y:CY-20, vx:0, vy:0, team:0, goalie:false }); // 2: wing
  players.push({ x:45, y:CY+20, vx:0, vy:0, team:0, goalie:false }); // 3: wing
  // Red team (right side, attacks left toward x=0)
  players.push({ x:190, y:CY, vx:0, vy:0, team:1, goalie:true }); // 4: goalie
  players.push({ x:140, y:CY, vx:0, vy:0, team:1, goalie:false }); // 5
  players.push({ x:155, y:CY-20, vx:0, vy:0, team:1, goalie:false }); // 6
  players.push({ x:155, y:CY+20, vx:0, vy:0, team:1, goalie:false }); // 7
}

function faceoff() {
  puck.x = CX; puck.y = CY; puck.vx = 0; puck.vy = 0; puck.owner = null;
  players[0].x = 10; players[0].y = CY;
  players[1].x = 95; players[1].y = CY;
  players[2].x = 80; players[2].y = CY - 20;
  players[3].x = 80; players[3].y = CY + 20;
  players[4].x = 190; players[4].y = CY;
  players[5].x = 105; players[5].y = CY;
  players[6].x = 120; players[6].y = CY - 20;
  players[7].x = 120; players[7].y = CY + 20;
  for (let p of players) { p.vx = 0; p.vy = 0; }
  faceoffTimer = 1.5;
  state = 'faceoff';
}

// ---- Input ----
let input = { x: 0, y: 0 };
let wantShoot = false, wantPass = false;
let keys = {};
document.addEventListener('keydown', e => { keys[e.code] = true; });
document.addEventListener('keyup', e => { keys[e.code] = false; });

function readKeys() {
  let ix = 0, iy = 0;
  if (keys['ArrowLeft'] || keys['KeyA']) ix -= 1;
  if (keys['ArrowRight'] || keys['KeyD']) ix += 1;
  if (keys['ArrowUp'] || keys['KeyW']) iy -= 1;
  if (keys['ArrowDown'] || keys['KeyS']) iy += 1;
  const m = Math.sqrt(ix*ix + iy*iy);
  if (m > 1) { ix /= m; iy /= m; }
  input.x = ix; input.y = iy;
  if (keys['Space']) { wantShoot = true; keys['Space'] = false; }
  if (keys['KeyE']) { wantPass = true; keys['KeyE'] = false; }
}

// ---- Touch joystick ----
let joyTouch = null, joyCenter = { x: 0, y: 0 };
const joyZone = document.getElementById('joyZone');
const joyBase = document.getElementById('joyBase');
const joyKnob = document.getElementById('joyKnob');
const isMobile = 'ontouchstart' in window;

joyZone.addEventListener('touchstart', e => {
  e.preventDefault();
  const t = e.changedTouches[0];
  joyTouch = t.identifier;
  joyCenter.x = t.clientX;
  joyCenter.y = t.clientY;
  joyBase.style.display = 'block';
  joyKnob.style.display = 'block';
  joyBase.style.left = (joyCenter.x - 60) + 'px';
  joyBase.style.top = (joyCenter.y - 60) + 'px';
  joyKnob.style.left = (joyCenter.x - 25) + 'px';
  joyKnob.style.top = (joyCenter.y - 25) + 'px';
}, { passive: false });

joyZone.addEventListener('touchmove', e => {
  e.preventDefault();
  for (const t of e.changedTouches) {
    if (t.identifier !== joyTouch) continue;
    let dx = t.clientX - joyCenter.x;
    let dy = t.clientY - joyCenter.y;
    const d = Math.sqrt(dx*dx + dy*dy);
    const maxR = 45;
    if (d > maxR) { dx *= maxR/d; dy *= maxR/d; }
    joyKnob.style.left = (joyCenter.x + dx - 25) + 'px';
    joyKnob.style.top = (joyCenter.y + dy - 25) + 'px';
    input.x = dx / maxR;
    input.y = dy / maxR;
  }
}, { passive: false });

function resetJoy() {
  joyTouch = null; input.x = 0; input.y = 0;
  joyBase.style.display = 'none';
  joyKnob.style.display = 'none';
}
joyZone.addEventListener('touchend', e => {
  for (const t of e.changedTouches) if (t.identifier === joyTouch) resetJoy();
});
joyZone.addEventListener('touchcancel', resetJoy);

document.getElementById('btnShoot').addEventListener('touchstart', e => { e.preventDefault(); wantShoot = true; }, { passive: false });
document.getElementById('btnPass').addEventListener('touchstart', e => { e.preventDefault(); wantPass = true; }, { passive: false });

// ---- Audio ----
let ac = null;
function ensureAudio() { if (!ac) try { ac = new (window.AudioContext || window.webkitAudioContext)(); } catch(e) {} }
function beep(freq, dur, type, vol) {
  if (!ac) return;
  try {
    const o = ac.createOscillator(), g = ac.createGain();
    o.type = type || 'square'; o.frequency.value = freq;
    g.gain.setValueAtTime(vol || 0.1, ac.currentTime);
    g.gain.exponentialRampToValueAtTime(0.001, ac.currentTime + dur);
    o.connect(g); g.connect(ac.destination);
    o.start(); o.stop(ac.currentTime + dur);
  } catch(e) {}
}
function sndGoal() { beep(200, 1.5, 'sawtooth', 0.25); setTimeout(() => beep(250, 1, 'sawtooth', 0.2), 150); }
function sndShot() { beep(600, 0.08, 'square', 0.12); }
function sndPass() { beep(400, 0.06, 'triangle', 0.1); }
function sndWhistle() { beep(800, 0.3, 'sine', 0.12); }

// ---- Helpers ----
function dist(a, b) { return Math.sqrt((a.x-b.x)**2 + (a.y-b.y)**2); }
function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }

// ---- Update ----
function update(dt) {
  if (state === 'faceoff') {
    faceoffTimer -= dt;
    if (faceoffTimer <= 0) { state = 'playing'; sndWhistle(); }
    return;
  }
  if (state !== 'playing') return;

  // Clock
  clock -= dt;
  if (clock <= 0) { clock = 0; endPeriod(); return; }

  // Read keyboard
  readKeys();

  // Human player (index 1)
  const human = players[1];
  human.vx += input.x * ACCEL * dt;
  human.vy += input.y * ACCEL * dt;

  // Shoot
  if (wantShoot) {
    wantShoot = false;
    if (puck.owner === human) {
      puck.owner = null;
      puck.vx = SHOT_SPD; puck.vy = 0; // shoot right toward red goal
      sndShot();
    }
  }

  // Pass
  if (wantPass) {
    wantPass = false;
    if (puck.owner === human) {
      let best = null, bestD = 999;
      for (let p of players) {
        if (p === human || p.team !== 0 || p.goalie) continue;
        const d = dist(human, p);
        if (d < bestD) { bestD = d; best = p; }
      }
      if (best) {
        puck.owner = null;
        const a = Math.atan2(best.y - human.y, best.x - human.x);
        puck.vx = Math.cos(a) * PASS_SPD;
        puck.vy = Math.sin(a) * PASS_SPD;
        sndPass();
      }
    }
  }

  // AI
  for (let i = 0; i < players.length; i++) {
    const p = players[i];
    if (i === 1) continue; // human
    if (p.goalie) {
      // Goalie: track puck Y, stay near goal line
      const gx = p.team === 0 ? 8 : 192;
      const ty = clamp(puck.y, CY - 15, CY + 15);
      p.vy += (ty - p.y) * 5 * dt;
      p.vx += (gx - p.x) * 5 * dt;
    } else if (puck.owner === p) {
      // Has puck â€” drive toward opponent goal
      const goalX = p.team === 0 ? 195 : 5;
      const a = Math.atan2(CY - p.y, goalX - p.x);
      p.vx += Math.cos(a) * ACCEL * 0.6 * dt;
      p.vy += Math.sin(a) * ACCEL * 0.6 * dt;
      // Shoot if close
      if ((p.team === 0 && p.x > 160) || (p.team === 1 && p.x < 40)) {
        puck.owner = null;
        const sx = p.team === 0 ? 1 : -1;
        puck.vx = sx * SHOT_SPD * 0.7;
        puck.vy = (Math.random() - 0.5) * 40;
        sndShot();
      }
    } else if (puck.owner && puck.owner.team !== p.team) {
      // Opponent has puck â€” chase
      const a = Math.atan2(puck.y - p.y, puck.x - p.x);
      p.vx += Math.cos(a) * ACCEL * 0.5 * dt;
      p.vy += Math.sin(a) * ACCEL * 0.5 * dt;
    } else if (!puck.owner) {
      // Loose puck â€” go for it
      const a = Math.atan2(puck.y - p.y, puck.x - p.x);
      p.vx += Math.cos(a) * ACCEL * 0.45 * dt;
      p.vy += Math.sin(a) * ACCEL * 0.45 * dt;
    } else {
      // Teammate has puck â€” get open
      const offX = p.team === 0 ? Math.min(puck.x + 30, 180) : Math.max(puck.x - 30, 20);
      const offY = p.y < CY ? CY - 18 : CY + 18;
      const a = Math.atan2(offY - p.y, offX - p.x);
      p.vx += Math.cos(a) * ACCEL * 0.3 * dt;
      p.vy += Math.sin(a) * ACCEL * 0.3 * dt;
    }
  }

  // Physics for all players
  for (let p of players) {
    p.vx *= Math.pow(FRICTION, dt * 60);
    p.vy *= Math.pow(FRICTION, dt * 60);
    const spd = Math.sqrt(p.vx**2 + p.vy**2);
    if (spd > MAX_SPD) { p.vx *= MAX_SPD/spd; p.vy *= MAX_SPD/spd; }
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    // Clamp to rink (with corner rounding approximation)
    p.x = clamp(p.x, PR, RW - PR);
    p.y = clamp(p.y, PR, RH - PR);
  }

  // Puck physics
  if (puck.owner) {
    puck.x = puck.owner.x + (puck.owner.team === 0 ? 3 : -3);
    puck.y = puck.owner.y;
    puck.vx = 0; puck.vy = 0;
  } else {
    puck.vx *= Math.pow(0.985, dt * 60);
    puck.vy *= Math.pow(0.985, dt * 60);
    puck.x += puck.vx * dt;
    puck.y += puck.vy * dt;

    // Bounce top/bottom boards
    if (puck.y < PKR) { puck.y = PKR; puck.vy *= -0.6; }
    if (puck.y > RH - PKR) { puck.y = RH - PKR; puck.vy *= -0.6; }

    // Left end: goal check
    if (puck.x < 3) {
      if (Math.abs(puck.y - CY) < GOAL_W / 2) {
        // Check goalie block
        if (dist(puck, players[0]) < GR + PKR + 2) {
          puck.vx *= -0.5; puck.x = 5;
        } else {
          doGoal(1); return; // Red scores
        }
      } else { puck.vx *= -0.6; puck.x = 3; }
    }
    // Right end: goal check
    if (puck.x > RW - 3) {
      if (Math.abs(puck.y - CY) < GOAL_W / 2) {
        if (dist(puck, players[4]) < GR + PKR + 2) {
          puck.vx *= -0.5; puck.x = RW - 5;
        } else {
          doGoal(0); return; // Blue scores
        }
      } else { puck.vx *= -0.6; puck.x = RW - 3; }
    }

    // Pickup
    for (let p of players) {
      if (puck.owner) break;
      if (dist(p, puck) < (p.goalie ? GR : PR) + PKR + 1) {
        puck.owner = p;
      }
    }
  }

  // Player collisions
  for (let i = 0; i < players.length; i++) {
    for (let j = i+1; j < players.length; j++) {
      const a = players[i], b = players[j];
      const d = dist(a, b);
      const minD = (a.goalie ? GR : PR) + (b.goalie ? GR : PR);
      if (d < minD && d > 0.1) {
        const nx = (b.x - a.x) / d, ny = (b.y - a.y) / d;
        const overlap = (minD - d) / 2;
        a.x -= nx * overlap; a.y -= ny * overlap;
        b.x += nx * overlap; b.y += ny * overlap;
        const dv = (a.vx - b.vx)*nx + (a.vy - b.vy)*ny;
        a.vx -= dv * 0.4 * nx; a.vy -= dv * 0.4 * ny;
        b.vx += dv * 0.4 * nx; b.vy += dv * 0.4 * ny;
        // Knock puck loose
        if (puck.owner === a || puck.owner === b) {
          puck.owner = null;
          puck.vx = (Math.random() - 0.5) * 60;
          puck.vy = (Math.random() - 0.5) * 60;
        }
      }
    }
  }

  // Update particles
  particles = particles.filter(p => {
    p.x += p.vx * dt; p.y += p.vy * dt;
    p.life -= dt; p.vx *= 0.95; p.vy *= 0.95;
    return p.life > 0;
  });
}

function doGoal(team) {
  score[team]++;
  state = 'goal';
  goalTimer = 2.5;
  sndGoal();
  document.getElementById('goalFlash').style.display = 'flex';
  // Particles at goal
  const gx = team === 0 ? RW - 3 : 3;
  for (let i = 0; i < 30; i++) {
    const a = Math.random() * Math.PI * 2, sp = 30 + Math.random() * 80;
    particles.push({ x: gx, y: CY, vx: Math.cos(a)*sp, vy: Math.sin(a)*sp, life: 1.5, color: team===0 ? '#4af' : '#f44' });
  }
}

function endPeriod() {
  sndWhistle();
  if (period >= 3 && score[0] !== score[1]) {
    state = 'over';
  } else if (period >= 3 && score[0] === score[1]) {
    period++;
    clock = PERIOD_SECS;
    faceoff();
  } else {
    period++;
    clock = PERIOD_SECS;
    faceoff();
  }
}

// ---- Draw ----
function drawRink() {
  // Boards (dark background behind rounded rect)
  ctx.fillStyle = '#1a2744';
  ctx.beginPath();
  const cr = ws(15);
  const x0 = rX, y0 = rY, w = rW, h = rH;
  ctx.moveTo(x0 + cr, y0);
  ctx.lineTo(x0 + w - cr, y0);
  ctx.arcTo(x0 + w, y0, x0 + w, y0 + cr, cr);
  ctx.lineTo(x0 + w, y0 + h - cr);
  ctx.arcTo(x0 + w, y0 + h, x0 + w - cr, y0 + h, cr);
  ctx.lineTo(x0 + cr, y0 + h);
  ctx.arcTo(x0, y0 + h, x0, y0 + h - cr, cr);
  ctx.lineTo(x0, y0 + cr);
  ctx.arcTo(x0, y0, x0 + cr, y0, cr);
  ctx.closePath();
  ctx.fill();

  // Ice surface (slightly inset)
  const ins = ws(1.5);
  ctx.fillStyle = '#e8eef4';
  ctx.beginPath();
  const cr2 = cr - ins;
  ctx.moveTo(x0+ins+cr2, y0+ins);
  ctx.lineTo(x0+w-ins-cr2, y0+ins);
  ctx.arcTo(x0+w-ins, y0+ins, x0+w-ins, y0+ins+cr2, cr2);
  ctx.lineTo(x0+w-ins, y0+h-ins-cr2);
  ctx.arcTo(x0+w-ins, y0+h-ins, x0+w-ins-cr2, y0+h-ins, cr2);
  ctx.lineTo(x0+ins+cr2, y0+h-ins);
  ctx.arcTo(x0+ins, y0+h-ins, x0+ins, y0+h-ins-cr2, cr2);
  ctx.lineTo(x0+ins, y0+ins+cr2);
  ctx.arcTo(x0+ins, y0+ins, x0+ins+cr2, y0+ins, cr2);
  ctx.closePath();
  ctx.fill();

  // Red center line
  ctx.strokeStyle = '#cc2222';
  ctx.lineWidth = ws(0.8);
  ctx.beginPath();
  ctx.moveTo(wx(CX), wy(1));
  ctx.lineTo(wx(CX), wy(RH-1));
  ctx.stroke();

  // Blue lines
  ctx.strokeStyle = '#2244cc';
  ctx.lineWidth = ws(0.6);
  ctx.beginPath();
  ctx.moveTo(wx(65), wy(1)); ctx.lineTo(wx(65), wy(RH-1));
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(wx(135), wy(1)); ctx.lineTo(wx(135), wy(RH-1));
  ctx.stroke();

  // Red goal lines
  ctx.strokeStyle = '#cc2222';
  ctx.lineWidth = ws(0.4);
  ctx.beginPath();
  ctx.moveTo(wx(11), wy(1)); ctx.lineTo(wx(11), wy(RH-1));
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(wx(189), wy(1)); ctx.lineTo(wx(189), wy(RH-1));
  ctx.stroke();

  // Center circle
  ctx.strokeStyle = '#cc2222';
  ctx.lineWidth = ws(0.4);
  ctx.beginPath();
  ctx.arc(wx(CX), wy(CY), ws(15), 0, Math.PI*2);
  ctx.stroke();

  // Center dot
  ctx.fillStyle = '#cc2222';
  ctx.beginPath();
  ctx.arc(wx(CX), wy(CY), ws(1), 0, Math.PI*2);
  ctx.fill();

  // Faceoff circles + dots in zones
  const faceoffs = [
    { x: 30, y: 20 }, { x: 30, y: 65 },
    { x: 170, y: 20 }, { x: 170, y: 65 }
  ];
  for (const f of faceoffs) {
    ctx.strokeStyle = '#cc2222';
    ctx.lineWidth = ws(0.3);
    ctx.beginPath();
    ctx.arc(wx(f.x), wy(f.y), ws(10), 0, Math.PI*2);
    ctx.stroke();
    ctx.fillStyle = '#cc2222';
    ctx.beginPath();
    ctx.arc(wx(f.x), wy(f.y), ws(0.8), 0, Math.PI*2);
    ctx.fill();
  }

  // Neutral zone faceoff dots
  const nDots = [{x:80,y:20},{x:80,y:65},{x:120,y:20},{x:120,y:65}];
  for (const d of nDots) {
    ctx.fillStyle = '#cc2222';
    ctx.beginPath();
    ctx.arc(wx(d.x), wy(d.y), ws(0.8), 0, Math.PI*2);
    ctx.fill();
  }

  // Goal creases (blue semicircles)
  ctx.fillStyle = 'rgba(70,150,255,0.25)';
  ctx.beginPath();
  ctx.arc(wx(11), wy(CY), ws(8), -Math.PI/2, Math.PI/2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(wx(189), wy(CY), ws(8), Math.PI/2, 3*Math.PI/2);
  ctx.fill();

  // Nets
  ctx.fillStyle = 'rgba(200,200,200,0.5)';
  ctx.fillRect(wx(0), wy(CY - GOAL_W/2), ws(5), ws(GOAL_W));
  ctx.strokeStyle = '#c33';
  ctx.lineWidth = ws(0.3);
  ctx.strokeRect(wx(0), wy(CY - GOAL_W/2), ws(5), ws(GOAL_W));

  ctx.fillStyle = 'rgba(200,200,200,0.5)';
  ctx.fillRect(wx(195), wy(CY - GOAL_W/2), ws(5), ws(GOAL_W));
  ctx.strokeStyle = '#c33';
  ctx.lineWidth = ws(0.3);
  ctx.strokeRect(wx(195), wy(CY - GOAL_W/2), ws(5), ws(GOAL_W));
}

function drawPlayers() {
  for (let i = 0; i < players.length; i++) {
    const p = players[i];
    const px = wx(p.x), py = wy(p.y);
    const r = ws(p.goalie ? GR : PR);

    // Shadow
    ctx.fillStyle = 'rgba(0,0,0,0.15)';
    ctx.beginPath();
    ctx.ellipse(px, py + r*0.4, r*1.1, r*0.4, 0, 0, Math.PI*2);
    ctx.fill();

    // Body
    ctx.fillStyle = p.team === 0 ? '#2266ff' : '#ee3333';
    ctx.beginPath();
    ctx.arc(px, py, r, 0, Math.PI*2);
    ctx.fill();
    ctx.strokeStyle = p.team === 0 ? '#1144cc' : '#cc1111';
    ctx.lineWidth = ws(0.3);
    ctx.stroke();

    // Goalie "G" label
    if (p.goalie) {
      ctx.fillStyle = '#fff';
      ctx.font = `bold ${Math.round(r*1.2)}px Arial`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('G', px, py);
    }

    // Human indicator (yellow ring + arrow)
    if (i === 1) {
      ctx.strokeStyle = '#ffee00';
      ctx.lineWidth = ws(0.4);
      ctx.beginPath();
      ctx.arc(px, py, r + ws(1), 0, Math.PI*2);
      ctx.stroke();
      // Arrow
      ctx.fillStyle = '#ffee00';
      ctx.beginPath();
      ctx.moveTo(px, py - r - ws(3));
      ctx.lineTo(px - ws(2), py - r - ws(1));
      ctx.lineTo(px + ws(2), py - r - ws(1));
      ctx.closePath();
      ctx.fill();
    }
  }
}

function drawPuck() {
  if (puck.owner) return; // drawn with player
  const px = wx(puck.x), py = wy(puck.y);
  const r = ws(PKR);
  ctx.fillStyle = '#111';
  ctx.beginPath();
  ctx.arc(px, py, r, 0, Math.PI*2);
  ctx.fill();
}

function drawParticles() {
  for (const p of particles) {
    ctx.globalAlpha = Math.min(1, p.life);
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(wx(p.x), wy(p.y), ws(1.5), 0, Math.PI*2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;
}

function drawHUD() {
  document.getElementById('sBlue').textContent = score[0];
  document.getElementById('sRed').textContent = score[1];
  const m = Math.floor(clock / 60), s = Math.floor(clock % 60);
  document.getElementById('sTime').textContent = m + ':' + String(s).padStart(2, '0');
  document.getElementById('sPer').textContent = period > 3 ? 'OT' : period;
}

function draw() {
  ctx.fillStyle = '#0a0a0a';
  ctx.fillRect(0, 0, W, H);
  resize();
  drawRink();
  drawPuck();
  drawPlayers();
  drawParticles();

  if (state === 'faceoff') {
    ctx.fillStyle = '#fff';
    ctx.font = `bold ${Math.round(ws(6))}px Arial`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(faceoffTimer > 0.8 ? 'FACE OFF' : 'GO!', wx(CX), wy(CY) - ws(12));
  }

  if (state === 'over') {
    ctx.fillStyle = 'rgba(0,0,0,0.7)';
    ctx.fillRect(0, 0, W, H);
    ctx.fillStyle = '#fff';
    ctx.font = `bold ${Math.round(ws(8))}px Arial`;
    ctx.textAlign = 'center';
    ctx.fillText('GAME OVER', W/2, H/2 - ws(6));
    ctx.font = `${Math.round(ws(5))}px Arial`;
    ctx.fillText(score[0] > score[1] ? 'ðŸ”µ BLUE WINS!' : 'ðŸ”´ RED WINS!', W/2, H/2 + ws(2));
    ctx.font = `${Math.round(ws(3))}px Arial`;
    ctx.fillStyle = '#888';
    ctx.fillText('Tap to play again', W/2, H/2 + ws(8));
  }

  drawHUD();
}

// ---- Game Loop ----
let lastT = 0;
function loop(ts) {
  const dt = Math.min((ts - (lastT || ts)) / 1000, 0.05);
  lastT = ts;

  if (state === 'goal') {
    goalTimer -= dt;
    particles = particles.filter(p => { p.x += p.vx*dt; p.y += p.vy*dt; p.life -= dt; return p.life > 0; });
    if (goalTimer <= 0) {
      document.getElementById('goalFlash').style.display = 'none';
      faceoff();
    }
  } else {
    update(dt);
  }

  draw();
  requestAnimationFrame(loop);
}

// ---- Start ----
function startGame() {
  document.getElementById('startScreen').style.display = 'none';
  document.getElementById('hud').style.display = 'block';
  if (isMobile) document.getElementById('controls').style.display = 'block';
  ensureAudio();
  if (ac) ac.resume();
  score = [0, 0]; period = 1; clock = PERIOD_SECS;
  makeTeams();
  faceoff();
  if (!lastT) requestAnimationFrame(loop);
}

// Play button
document.getElementById('playBtn').addEventListener('click', e => { e.stopPropagation(); startGame(); });
document.getElementById('playBtn').addEventListener('touchend', e => { e.preventDefault(); startGame(); });

// Restart from game over
document.addEventListener('click', () => { if (state === 'over') startGame(); });
document.addEventListener('touchend', () => { if (state === 'over') startGame(); });
</script>
</body>
</html>
