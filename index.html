<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no,maximum-scale=1.0">
<title>Overtime ‚Äî 3v3 Hockey</title>
<style>
*{margin:0;padding:0;box-sizing:border-box;}
html,body{width:100%;height:100%;overflow:hidden;background:#111;font-family:'Segoe UI',Arial,sans-serif;touch-action:none;user-select:none;-webkit-user-select:none;}
canvas{display:block;width:100%;height:100%;}
#ui-overlay{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:10;}
#start-screen{position:absolute;top:0;left:0;width:100%;height:100%;background:linear-gradient(135deg,#0a1628 0%,#1a3a5c 50%,#0a1628 100%);display:flex;flex-direction:column;align-items:center;justify-content:center;z-index:100;pointer-events:all;}
#start-screen h1{font-size:min(18vw,120px);color:#fff;text-shadow:0 0 40px #4af,0 0 80px #28f,0 4px 0 #036;letter-spacing:6px;margin-bottom:10px;font-weight:900;}
#start-screen .sub{color:#8cf;font-size:min(4vw,22px);margin-bottom:40px;letter-spacing:3px;}
#play-btn{background:linear-gradient(180deg,#ff4444,#cc0000);color:#fff;border:none;padding:18px 60px;font-size:min(6vw,32px);font-weight:700;border-radius:50px;cursor:pointer;letter-spacing:2px;box-shadow:0 4px 20px rgba(255,0,0,.4);transition:transform .1s;}
#play-btn:active{transform:scale(.95);}
#start-screen .controls-hint{color:#689;font-size:min(3vw,14px);margin-top:30px;text-align:center;line-height:1.8;}
#hud{position:absolute;top:0;left:0;width:100%;display:flex;justify-content:center;align-items:flex-start;pointer-events:none;z-index:20;}
#scoreboard{background:rgba(0,0,0,.75);color:#fff;padding:6px 20px;border-radius:0 0 12px 12px;display:flex;gap:20px;align-items:center;font-size:min(4.5vw,22px);font-weight:700;backdrop-filter:blur(4px);}
#scoreboard .team{display:flex;align-items:center;gap:6px;}
#scoreboard .blue{color:#4af;}
#scoreboard .red{color:#f44;}
#scoreboard .period{color:#aaa;font-size:.8em;}
#msg-overlay{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);color:#fff;font-size:min(10vw,60px);font-weight:900;text-shadow:0 0 30px #f44,0 0 60px #f00;pointer-events:none;z-index:30;opacity:0;transition:opacity .3s;}
#touch-controls{position:absolute;bottom:0;left:0;width:100%;height:40%;pointer-events:all;z-index:15;display:none;}
.touch-btn{position:absolute;width:70px;height:70px;border-radius:50%;display:flex;align-items:center;justify-content:center;font-weight:700;font-size:16px;color:#fff;border:2px solid rgba(255,255,255,.3);}
#btn-shoot{background:rgba(255,50,50,.4);right:20px;bottom:100px;}
#btn-pass{background:rgba(50,150,255,.4);right:100px;bottom:40px;}
#joystick-area{position:absolute;left:0;bottom:0;width:50%;height:100%;}
#joystick-base{position:absolute;width:120px;height:120px;border-radius:50%;border:2px solid rgba(255,255,255,.15);background:rgba(255,255,255,.05);display:none;}
#joystick-thumb{position:absolute;width:50px;height:50px;border-radius:50%;background:rgba(255,255,255,.3);display:none;}
#period-screen{position:absolute;top:0;left:0;width:100%;height:100%;background:rgba(0,0,20,.85);display:none;flex-direction:column;align-items:center;justify-content:center;z-index:90;pointer-events:all;}
#period-screen h2{color:#fff;font-size:min(8vw,48px);margin-bottom:10px;}
#period-screen .score-display{color:#ccc;font-size:min(6vw,36px);margin-bottom:30px;}
#period-screen button{background:linear-gradient(180deg,#4af,#28c);color:#fff;border:none;padding:14px 40px;font-size:min(5vw,24px);border-radius:40px;cursor:pointer;font-weight:700;}
</style>
</head>
<body>

<div id="start-screen">
  <h1>OVERTIME</h1>
  <div class="sub">3 v 3 HOCKEY</div>
  <button id="play-btn">‚ñ∂ PLAY</button>
  <div class="controls-hint">
    üéÆ Mobile: Touch joystick + buttons<br>
    ‚å®Ô∏è Desktop: WASD / Arrows ¬∑ Space = Shoot ¬∑ E = Pass
  </div>
</div>

<canvas id="c"></canvas>

<div id="ui-overlay">
  <div id="hud" style="display:none;">
    <div id="scoreboard">
      <div class="team blue">üîµ <span id="score-blue">0</span></div>
      <div class="period"><span id="period-display">P1</span> <span id="time-display">2:00</span></div>
      <div class="team red"><span id="score-red">0</span> üî¥</div>
    </div>
  </div>
  <div id="msg-overlay"></div>
</div>

<div id="touch-controls">
  <div id="joystick-area">
    <div id="joystick-base"></div>
    <div id="joystick-thumb"></div>
  </div>
  <div id="btn-shoot" class="touch-btn">SHOT</div>
  <div id="btn-pass" class="touch-btn">PASS</div>
</div>

<div id="period-screen">
  <h2 id="period-title"></h2>
  <div class="score-display" id="period-score"></div>
  <button id="period-btn">Continue</button>
</div>

<script>
// ===== GAME ENGINE =====
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

// --- Audio ---
let audioCtx;
function initAudio(){if(!audioCtx)audioCtx=new(window.AudioContext||window.webkitAudioContext)();}
function playSound(freq,dur,type='square',vol=.15){
  if(!audioCtx)return;
  const o=audioCtx.createOscillator(),g=audioCtx.createGain();
  o.type=type;o.frequency.value=freq;
  g.gain.setValueAtTime(vol,audioCtx.currentTime);
  g.gain.exponentialRampToValueAtTime(.001,audioCtx.currentTime+dur);
  o.connect(g);g.connect(audioCtx.destination);
  o.start();o.stop(audioCtx.currentTime+dur);
}
function playGoalHorn(){
  if(!audioCtx)return;
  [200,250,300].forEach((f,i)=>{setTimeout(()=>playSound(f,.8,'sawtooth',.2),i*100);});
  setTimeout(()=>{for(let i=0;i<5;i++)setTimeout(()=>playSound(800+Math.random()*400,.1,'square',.1),i*150);},900);
}
function playShot(){playSound(600,.08,'square',.12);}
function playPass(){playSound(400,.06,'triangle',.1);}
function playWhistle(){playSound(900,.4,'sine',.15);setTimeout(()=>playSound(700,.3,'sine',.1),200);}

// --- Constants ---
const RINK_W = 800, RINK_H = 1700; // world coords: full rink
const GOAL_W = 120, GOAL_D = 40;
const PERIOD_TIME = 120; // 2 min
const MAX_PERIODS = 3;
const FRICTION = 0.985;
const ACCEL = 0.45;
const MAX_SPEED = 4.5;
const PUCK_FRICTION = 0.992;
const SHOT_SPEED = 14;
const PASS_SPEED = 8;
const PLAYER_R = 15; // world radius

// --- State ---
let W, H; // canvas pixel size
let gameState = 'menu'; // menu, playing, faceoff, goal, periodEnd, gameOver
let score = [0, 0]; // blue, red
let period = 1;
let timeLeft = PERIOD_TIME;
let lastTime = 0;
let msgTimer = 0;
let goalCelebTimer = 0;
let faceoffTimer = 0;
let particles = [];

// --- Input ---
let keys = {};
let joystickVec = {x:0,y:0};
let shootPressed = false, passPressed = false;
let isMobile = false;

// --- Entities ---
let players = []; // index 0 = human player
let puck = {x:0,y:0,vx:0,vy:0,carrier:null};
let goalies = []; // 0=blue(bottom), 1=red(top)

function resize(){
  W = canvas.width = window.innerWidth * devicePixelRatio;
  H = canvas.height = window.innerHeight * devicePixelRatio;
  canvas.style.width = window.innerWidth+'px';
  canvas.style.height = window.innerHeight+'px';
}
window.addEventListener('resize', resize);
resize();

// --- Perspective projection ---
// Camera behind player looking up-ice. World Y: 0=top(far goal), RINK_H=bottom(near goal).
// Player's team attacks upward (toward Y=0).
// We project world coords to screen coords with perspective.

function worldToScreen(wx, wy){
  // Normalize Y: 0(far)..1(near) relative to camera
  // Camera follows player Y somewhat
  const camY = players[0] ? players[0].y : RINK_H/2;
  const viewRange = RINK_H * 0.85;
  const viewTop = camY - viewRange * 0.7; // see more ahead
  const viewBot = camY + viewRange * 0.3;
  
  let ny = (wy - viewTop) / (viewBot - viewTop); // 0=far, 1=near
  ny = Math.max(0.01, Math.min(1.2, ny));
  
  // Perspective: near things wider, far things narrower
  const perspective = 0.3 + 0.7 * ny; // scale factor
  const vanishX = W / 2;
  
  // X: center on player somewhat
  const camX = players[0] ? players[0].x : RINK_W/2;
  const nx = (wx - camX) / RINK_W; // -0.5 to 0.5 centered on player
  
  const sx = vanishX + nx * W * 1.1 * perspective;
  const sy = H * 0.08 + (1 - ny) * H * 0.85; // far=top, near=bottom (inverted because far at top of screen)
  // Wait, let's reconsider: ny=0 is far (top of screen), ny=1 is near (bottom)
  // So screen Y should be: small for far, large for near
  const screenY = H * 0.05 + ny * H * 0.88;
  
  return {x: sx, y: screenY, scale: perspective};
}

function getScale(wy){
  const camY = players[0] ? players[0].y : RINK_H/2;
  const viewRange = RINK_H * 0.85;
  const viewTop = camY - viewRange * 0.7;
  const viewBot = camY + viewRange * 0.3;
  let ny = (wy - viewTop) / (viewBot - viewTop);
  ny = Math.max(0.01, Math.min(1.2, ny));
  return 0.3 + 0.7 * ny;
}

// --- Init game ---
function initGame(){
  score = [0,0];
  period = 1;
  timeLeft = PERIOD_TIME;
  initPeriod();
}

function initPeriod(){
  players = [];
  // Blue team (bottom, attacks up toward Y=0)
  // Player 0 = human
  players.push({x:RINK_W/2, y:RINK_H*0.65, vx:0, vy:0, team:0, isHuman:true, r:PLAYER_R});
  players.push({x:RINK_W/2-120, y:RINK_H*0.55, vx:0, vy:0, team:0, isHuman:false, r:PLAYER_R});
  players.push({x:RINK_W/2+120, y:RINK_H*0.55, vx:0, vy:0, team:0, isHuman:false, r:PLAYER_R});
  // Red team (top, attacks down toward Y=RINK_H)
  players.push({x:RINK_W/2, y:RINK_H*0.35, vx:0, vy:0, team:1, isHuman:false, r:PLAYER_R});
  players.push({x:RINK_W/2-120, y:RINK_H*0.45, vx:0, vy:0, team:1, isHuman:false, r:PLAYER_R});
  players.push({x:RINK_W/2+120, y:RINK_H*0.45, vx:0, vy:0, team:1, isHuman:false, r:PLAYER_R});
  
  // Goalies
  goalies = [
    {x:RINK_W/2, y:RINK_H-50, vx:0, team:0, r:18}, // blue goalie (bottom)
    {x:RINK_W/2, y:50, vx:0, team:1, r:18}           // red goalie (top)
  ];
  
  resetForFaceoff();
}

function resetForFaceoff(){
  // Center faceoff
  puck.x = RINK_W/2; puck.y = RINK_H/2;
  puck.vx = 0; puck.vy = 0; puck.carrier = null;
  
  // Position players for faceoff
  players[0].x = RINK_W/2; players[0].y = RINK_H/2 + 40;
  players[1].x = RINK_W/2 - 100; players[1].y = RINK_H/2 + 80;
  players[2].x = RINK_W/2 + 100; players[2].y = RINK_H/2 + 80;
  players[3].x = RINK_W/2; players[3].y = RINK_H/2 - 40;
  players[4].x = RINK_W/2 - 100; players[4].y = RINK_H/2 - 80;
  players[5].x = RINK_W/2 + 100; players[5].y = RINK_H/2 - 80;
  
  players.forEach(p => {p.vx=0;p.vy=0;});
  goalies[0].x = RINK_W/2; goalies[1].x = RINK_W/2;
  
  faceoffTimer = 1.5;
  gameState = 'faceoff';
}

// --- Update ---
function update(dt){
  if(gameState === 'faceoff'){
    faceoffTimer -= dt;
    if(faceoffTimer <= 0) gameState = 'playing';
    return;
  }
  if(gameState === 'goal'){
    goalCelebTimer -= dt;
    updateParticles(dt);
    if(goalCelebTimer <= 0){
      resetForFaceoff();
    }
    return;
  }
  if(gameState === 'periodEnd' || gameState === 'gameOver' || gameState === 'menu') return;
  
  // Timer
  timeLeft -= dt;
  if(timeLeft <= 0){
    timeLeft = 0;
    endPeriod();
    return;
  }
  
  // Player input
  let ix = 0, iy = 0;
  if(isMobile){
    ix = joystickVec.x; iy = joystickVec.y;
  } else {
    if(keys['ArrowLeft']||keys['KeyA']) ix = -1;
    if(keys['ArrowRight']||keys['KeyD']) ix = 1;
    if(keys['ArrowUp']||keys['KeyW']) iy = -1;
    if(keys['ArrowDown']||keys['KeyS']) iy = 1;
    const mag = Math.sqrt(ix*ix+iy*iy);
    if(mag>1){ix/=mag;iy/=mag;}
  }
  
  const p = players[0];
  p.vx += ix * ACCEL;
  p.vy += iy * ACCEL;
  
  // Shoot
  if(shootPressed || keys['Space']){
    if(puck.carrier === p){
      puck.carrier = null;
      puck.vx = 0;
      puck.vy = -SHOT_SPEED; // shoot toward far goal
      playShot();
    }
    shootPressed = false;
    keys['Space'] = false;
  }
  
  // Pass
  if(passPressed || keys['KeyE']){
    if(puck.carrier === p){
      // Find nearest teammate
      let best = null, bestD = Infinity;
      players.forEach(t => {
        if(t === p || t.team !== p.team) return;
        const d = dist(p,t);
        if(d < bestD){bestD=d;best=t;}
      });
      if(best){
        puck.carrier = null;
        const a = Math.atan2(best.y-p.y, best.x-p.x);
        puck.vx = Math.cos(a)*PASS_SPEED;
        puck.vy = Math.sin(a)*PASS_SPEED;
        playPass();
      }
    }
    passPressed = false;
    keys['KeyE'] = false;
  }
  
  // Update all players
  players.forEach(pl => {
    if(!pl.isHuman) updateAI(pl, dt);
    pl.vx *= FRICTION;
    pl.vy *= FRICTION;
    const spd = Math.sqrt(pl.vx*pl.vx+pl.vy*pl.vy);
    if(spd > MAX_SPEED){pl.vx*=MAX_SPEED/spd;pl.vy*=MAX_SPEED/spd;}
    pl.x += pl.vx;
    pl.y += pl.vy;
    // Clamp to rink
    pl.x = Math.max(30, Math.min(RINK_W-30, pl.x));
    pl.y = Math.max(30, Math.min(RINK_H-30, pl.y));
  });
  
  // Update goalies
  goalies.forEach((g,i) => {
    const goalY = i===0 ? RINK_H-50 : 50;
    const targetX = Math.max(RINK_W/2-GOAL_W/2+20, Math.min(RINK_W/2+GOAL_W/2-20, puck.x));
    g.x += (targetX - g.x) * 0.06;
    g.y = goalY;
  });
  
  // Update puck
  if(puck.carrier){
    // Puck follows carrier, slightly ahead
    const c = puck.carrier;
    const dir = Math.atan2(c.vy, c.vx);
    puck.x = c.x + Math.cos(dir)*20;
    puck.y = c.y + Math.sin(dir)*20;
    if(Math.abs(c.vx)<0.1 && Math.abs(c.vy)<0.1){
      puck.x = c.x; puck.y = c.y - 15;
    }
  } else {
    puck.vx *= PUCK_FRICTION;
    puck.vy *= PUCK_FRICTION;
    puck.x += puck.vx;
    puck.y += puck.vy;
    
    // Bounce off walls
    if(puck.x < 15 || puck.x > RINK_W-15){puck.vx *= -0.7; puck.x = Math.max(15,Math.min(RINK_W-15,puck.x));}
    
    // Check goal or bounce off end boards
    // Top goal (red team's goal, blue scores): Y < 20, within goal width
    if(puck.y < 20){
      if(Math.abs(puck.x - RINK_W/2) < GOAL_W/2){
        // Check if goalie blocks
        if(Math.abs(puck.x - goalies[1].x) < goalies[1].r + 8){
          puck.vy *= -0.5; puck.y = 25;
        } else {
          goalScored(0); return; // Blue scores!
        }
      } else {
        puck.vy *= -0.7; puck.y = 20;
      }
    }
    // Bottom goal (blue team's goal, red scores): Y > RINK_H-20
    if(puck.y > RINK_H-20){
      if(Math.abs(puck.x - RINK_W/2) < GOAL_W/2){
        if(Math.abs(puck.x - goalies[0].x) < goalies[0].r + 8){
          puck.vy *= -0.5; puck.y = RINK_H-25;
        } else {
          goalScored(1); return; // Red scores!
        }
      } else {
        puck.vy *= -0.7; puck.y = RINK_H-20;
      }
    }
    
    // Pickup: any player near puck can grab it
    let allEntities = [...players, ...goalies];
    allEntities.forEach(pl => {
      if(puck.carrier) return;
      if(dist(pl, puck) < (pl.r || PLAYER_R) + 10){
        puck.carrier = pl;
      }
    });
  }
  
  // Player-player collision
  for(let i=0;i<players.length;i++){
    for(let j=i+1;j<players.length;j++){
      const a=players[i],b=players[j];
      const d=dist(a,b);
      if(d < a.r+b.r){
        const nx=(b.x-a.x)/d, ny=(b.y-a.y)/d;
        const overlap = (a.r+b.r-d)/2;
        a.x -= nx*overlap; a.y -= ny*overlap;
        b.x += nx*overlap; b.y += ny*overlap;
        // Swap velocities partially
        const dvx = a.vx-b.vx, dvy = a.vy-b.vy;
        a.vx -= dvx*0.3; a.vy -= dvy*0.3;
        b.vx += dvx*0.3; b.vy += dvy*0.3;
        // Puck knock-loose
        if(puck.carrier === a || puck.carrier === b){
          puck.carrier = null;
          puck.vx = (Math.random()-0.5)*3;
          puck.vy = (Math.random()-0.5)*3;
        }
      }
    }
  }
  
  updateParticles(dt);
}

function dist(a,b){return Math.sqrt((a.x-b.x)**2+(a.y-b.y)**2);}

function updateAI(pl, dt){
  const hasPuck = puck.carrier === pl;
  const teamAttackDir = pl.team === 0 ? -1 : 1; // blue attacks up (neg Y), red attacks down (pos Y)
  const goalY = pl.team === 0 ? 0 : RINK_H;
  
  if(hasPuck){
    // Move toward opponent goal
    const tx = RINK_W/2 + (Math.random()-0.5)*100;
    const ty = goalY;
    const a = Math.atan2(ty-pl.y, tx-pl.x);
    pl.vx += Math.cos(a)*ACCEL*0.6;
    pl.vy += Math.sin(a)*ACCEL*0.6;
    // Shoot if close to goal
    if(Math.abs(pl.y - goalY) < 400){
      puck.carrier = null;
      puck.vx = (Math.random()-0.5)*2;
      puck.vy = teamAttackDir * SHOT_SPEED * 0.8;
      playShot();
    }
  } else if(puck.carrier && puck.carrier.team !== pl.team){
    // Chase puck carrier
    const a = Math.atan2(puck.carrier.y-pl.y, puck.carrier.x-pl.x);
    pl.vx += Math.cos(a)*ACCEL*0.45;
    pl.vy += Math.sin(a)*ACCEL*0.45;
  } else if(!puck.carrier){
    // Go for loose puck
    const a = Math.atan2(puck.y-pl.y, puck.x-pl.x);
    pl.vx += Math.cos(a)*ACCEL*0.4;
    pl.vy += Math.sin(a)*ACCEL*0.4;
  } else {
    // Teammate has puck ‚Äî get open
    const homeY = pl.team === 0 ? RINK_H*0.5 : RINK_H*0.5;
    const laneX = pl.x < RINK_W/2 ? RINK_W*0.25 : RINK_W*0.75;
    const targetY = goalY === 0 ? Math.max(100, puck.carrier.y - 200) : Math.min(RINK_H-100, puck.carrier.y + 200);
    const a = Math.atan2(targetY-pl.y, laneX-pl.x);
    pl.vx += Math.cos(a)*ACCEL*0.3;
    pl.vy += Math.sin(a)*ACCEL*0.3;
  }
}

function goalScored(team){
  score[team]++;
  gameState = 'goal';
  goalCelebTimer = 2.5;
  playGoalHorn();
  showMsg(team===0?'üîµ GOAL!':'üî¥ GOAL!');
  // Particles
  const gx = RINK_W/2, gy = team===0 ? 30 : RINK_H-30;
  for(let i=0;i<40;i++){
    particles.push({
      x:gx, y:gy,
      vx:(Math.random()-0.5)*8, vy:(Math.random()-0.5)*8,
      life:1+Math.random(), color: team===0?'#4af':'#f44', r:3+Math.random()*4
    });
  }
  updateHUD();
}

function endPeriod(){
  playWhistle();
  if(period >= MAX_PERIODS){
    if(score[0] === score[1]){
      // Overtime!
      period++;
      showPeriodScreen('OVERTIME','Sudden Death!');
    } else {
      gameState = 'gameOver';
      showPeriodScreen('GAME OVER', score[0]>score[1]?'üîµ Blue Wins!':'üî¥ Red Wins!');
    }
  } else {
    showPeriodScreen(`End of Period ${period}`, '');
    period++;
  }
}

function showPeriodScreen(title, sub){
  gameState = 'periodEnd';
  const el = document.getElementById('period-screen');
  document.getElementById('period-title').textContent = title;
  document.getElementById('period-score').textContent = `${score[0]} ‚Äî ${score[1]}` + (sub ? '\n'+sub : '');
  el.style.display = 'flex';
  const btn = document.getElementById('period-btn');
  btn.textContent = gameState==='gameOver'?'Play Again':'Continue';
  btn.onclick = ()=>{
    el.style.display='none';
    if(title==='GAME OVER'){
      initGame();
    } else {
      timeLeft = PERIOD_TIME;
      initPeriod();
    }
  };
}

function showMsg(txt){
  const el = document.getElementById('msg-overlay');
  el.textContent = txt;
  el.style.opacity = '1';
  msgTimer = 2;
}

function updateHUD(){
  document.getElementById('score-blue').textContent = score[0];
  document.getElementById('score-red').textContent = score[1];
  const m = Math.floor(timeLeft/60), s = Math.floor(timeLeft%60);
  document.getElementById('time-display').textContent = `${m}:${s.toString().padStart(2,'0')}`;
  document.getElementById('period-display').textContent = period > MAX_PERIODS ? 'OT' : `P${period}`;
}

function updateParticles(dt){
  particles = particles.filter(p => {
    p.x += p.vx; p.y += p.vy;
    p.life -= dt;
    p.vx *= 0.97; p.vy *= 0.97;
    return p.life > 0;
  });
}

// ===== DRAW =====
function draw(){
  ctx.fillStyle = '#111';
  ctx.fillRect(0, 0, W, H);
  
  drawRink();
  
  // Collect all drawable entities, sort by Y (far first)
  let drawables = [];
  players.forEach(p => drawables.push({type:'player', e:p}));
  goalies.forEach(g => drawables.push({type:'goalie', e:g}));
  if(!puck.carrier) drawables.push({type:'puck', e:puck});
  
  drawables.sort((a,b) => a.e.y - b.e.y); // far (small Y) first
  
  drawables.forEach(d => {
    if(d.type==='puck') drawPuck(d.e);
    else if(d.type==='goalie') drawGoalie(d.e);
    else drawPlayer(d.e);
  });
  
  // Draw puck on carrier
  if(puck.carrier) drawPuck(puck);
  
  // Particles
  particles.forEach(p => {
    const s = worldToScreen(p.x, p.y);
    ctx.globalAlpha = Math.min(1, p.life);
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(s.x, s.y, p.r * s.scale, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;
  });
  
  // Goal flash
  if(gameState==='goal' && goalCelebTimer > 1.5){
    ctx.fillStyle = `rgba(255,255,255,${(goalCelebTimer-1.5)/1.0*0.3})`;
    ctx.fillRect(0,0,W,H);
  }
  
  // Faceoff indicator
  if(gameState==='faceoff'){
    const s = worldToScreen(RINK_W/2, RINK_H/2);
    ctx.fillStyle = '#fff';
    ctx.font = `bold ${30*devicePixelRatio}px sans-serif`;
    ctx.textAlign = 'center';
    ctx.fillText(faceoffTimer > 1 ? 'READY' : 'GO!', s.x, s.y - 40*s.scale);
  }
  
  // Msg fade
  if(msgTimer > 0){
    msgTimer -= 1/60;
    if(msgTimer <= 0){
      document.getElementById('msg-overlay').style.opacity = '0';
    }
  }
}

function drawRink(){
  // Draw ice surface as perspective trapezoid
  const corners = [
    worldToScreen(0, 0),         // far-left
    worldToScreen(RINK_W, 0),    // far-right
    worldToScreen(RINK_W, RINK_H), // near-right
    worldToScreen(0, RINK_H)     // near-left
  ];
  
  // Ice
  ctx.fillStyle = '#dce8f0';
  ctx.beginPath();
  ctx.moveTo(corners[0].x, corners[0].y);
  ctx.lineTo(corners[1].x, corners[1].y);
  ctx.lineTo(corners[2].x, corners[2].y);
  ctx.lineTo(corners[3].x, corners[3].y);
  ctx.closePath();
  ctx.fill();
  
  // Rink border
  ctx.strokeStyle = '#345';
  ctx.lineWidth = 3 * devicePixelRatio;
  ctx.stroke();
  
  // Lines
  drawRinkLine(RINK_H/2, '#44f', 2);   // center red... wait, blue line? Let's do it right
  drawRinkLine(RINK_H/2, '#c22', 3);    // center line (red)
  drawRinkLine(RINK_H*0.3, '#44f', 2);  // blue line (far)
  drawRinkLine(RINK_H*0.7, '#44f', 2);  // blue line (near)
  
  // Center circle
  drawCircleOnIce(RINK_W/2, RINK_H/2, 80, '#c22', 2);
  
  // Faceoff circles
  [RINK_H*0.2, RINK_H*0.8].forEach(fy => {
    [RINK_W*0.25, RINK_W*0.75].forEach(fx => {
      drawCircleOnIce(fx, fy, 50, '#c22', 1.5);
    });
  });
  
  // Goal creases
  drawCrease(RINK_W/2, 30, '#adf');   // top
  drawCrease(RINK_W/2, RINK_H-30, '#adf'); // bottom
  
  // Nets
  drawNet(RINK_W/2, 10);
  drawNet(RINK_W/2, RINK_H-10);
}

function drawRinkLine(wy, color, width){
  const l = worldToScreen(20, wy);
  const r = worldToScreen(RINK_W-20, wy);
  ctx.strokeStyle = color;
  ctx.lineWidth = width * devicePixelRatio * l.scale;
  ctx.beginPath();
  ctx.moveTo(l.x, l.y);
  ctx.lineTo(r.x, r.y);
  ctx.stroke();
}

function drawCircleOnIce(cx, cy, r, color, width){
  ctx.strokeStyle = color;
  const sc = getScale(cy);
  ctx.lineWidth = width * devicePixelRatio * sc;
  ctx.beginPath();
  const steps = 32;
  for(let i=0;i<=steps;i++){
    const a = (i/steps)*Math.PI*2;
    const px = cx + Math.cos(a)*r;
    const py = cy + Math.sin(a)*r;
    const s = worldToScreen(px, py);
    if(i===0) ctx.moveTo(s.x, s.y);
    else ctx.lineTo(s.x, s.y);
  }
  ctx.stroke();
}

function drawCrease(cx, cy, color){
  ctx.fillStyle = color;
  ctx.globalAlpha = 0.3;
  ctx.beginPath();
  const steps = 16;
  const r = 40;
  for(let i=0;i<=steps;i++){
    const a = (i/steps)*Math.PI;
    const px = cx + Math.cos(a)*r;
    const py = cy + (cy < RINK_H/2 ? 1 : -1)*Math.sin(a)*r;
    const s = worldToScreen(px, py);
    if(i===0) ctx.moveTo(s.x, s.y);
    else ctx.lineTo(s.x, s.y);
  }
  ctx.fill();
  ctx.globalAlpha = 1;
}

function drawNet(cx, cy){
  const l = worldToScreen(cx-GOAL_W/2, cy);
  const r = worldToScreen(cx+GOAL_W/2, cy);
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 3 * devicePixelRatio * l.scale;
  ctx.beginPath();
  ctx.moveTo(l.x, l.y);
  ctx.lineTo(r.x, r.y);
  ctx.stroke();
  // Net mesh look
  const back = worldToScreen(cx, cy + (cy < RINK_H/2 ? -GOAL_D : GOAL_D));
  ctx.strokeStyle = 'rgba(255,255,255,0.3)';
  ctx.lineWidth = 1 * devicePixelRatio;
  ctx.beginPath();
  ctx.moveTo(l.x, l.y); ctx.lineTo(back.x, back.y); ctx.lineTo(r.x, r.y);
  ctx.stroke();
}

function drawPlayer(p){
  const s = worldToScreen(p.x, p.y);
  const r = PLAYER_R * s.scale * devicePixelRatio * 0.08;
  
  // Shadow
  ctx.fillStyle = 'rgba(0,0,0,0.2)';
  ctx.beginPath();
  ctx.ellipse(s.x, s.y + r*0.5, r*1.2, r*0.4, 0, 0, Math.PI*2);
  ctx.fill();
  
  // Body
  const color = p.team === 0 ? '#2266ff' : '#ee3333';
  const light = p.team === 0 ? '#4488ff' : '#ff6666';
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.arc(s.x, s.y - r*0.3, r, 0, Math.PI*2);
  ctx.fill();
  
  // Highlight
  ctx.fillStyle = light;
  ctx.beginPath();
  ctx.arc(s.x - r*0.2, s.y - r*0.6, r*0.4, 0, Math.PI*2);
  ctx.fill();
  
  // Human indicator
  if(p.isHuman){
    ctx.strokeStyle = '#ff0';
    ctx.lineWidth = 2 * devicePixelRatio * s.scale;
    ctx.beginPath();
    ctx.arc(s.x, s.y - r*0.3, r*1.4, 0, Math.PI*2);
    ctx.stroke();
    // Arrow above
    ctx.fillStyle = '#ff0';
    ctx.beginPath();
    const ay = s.y - r*2.2;
    ctx.moveTo(s.x, ay - r*0.6);
    ctx.lineTo(s.x - r*0.4, ay);
    ctx.lineTo(s.x + r*0.4, ay);
    ctx.closePath();
    ctx.fill();
  }
}

function drawGoalie(g){
  const s = worldToScreen(g.x, g.y);
  const r = 18 * s.scale * devicePixelRatio * 0.08;
  
  ctx.fillStyle = 'rgba(0,0,0,0.2)';
  ctx.beginPath();
  ctx.ellipse(s.x, s.y + r*0.5, r*1.5, r*0.5, 0, 0, Math.PI*2);
  ctx.fill();
  
  const color = g.team === 0 ? '#1144cc' : '#cc1111';
  ctx.fillStyle = color;
  ctx.beginPath();
  // Wider shape for goalie
  ctx.ellipse(s.x, s.y - r*0.2, r*1.3, r*1.1, 0, 0, Math.PI*2);
  ctx.fill();
  
  // Mask
  ctx.fillStyle = '#fff';
  ctx.beginPath();
  ctx.arc(s.x, s.y - r*0.5, r*0.5, 0, Math.PI*2);
  ctx.fill();
}

function drawPuck(p){
  const s = worldToScreen(p.x, p.y);
  const r = 6 * s.scale * devicePixelRatio * 0.08;
  
  // Shadow
  ctx.fillStyle = 'rgba(0,0,0,0.3)';
  ctx.beginPath();
  ctx.ellipse(s.x+r*0.3, s.y+r*0.5, r*1.2, r*0.5, 0, 0, Math.PI*2);
  ctx.fill();
  
  // Puck
  ctx.fillStyle = '#111';
  ctx.beginPath();
  ctx.arc(s.x, s.y, Math.max(r, 2*devicePixelRatio), 0, Math.PI*2);
  ctx.fill();
  
  // Highlight
  ctx.fillStyle = '#555';
  ctx.beginPath();
  ctx.arc(s.x - r*0.2, s.y - r*0.2, r*0.4, 0, Math.PI*2);
  ctx.fill();
}

// ===== GAME LOOP =====
function loop(ts){
  const dt = Math.min((ts - lastTime)/1000, 0.05);
  lastTime = ts;
  
  if(gameState === 'playing' || gameState === 'faceoff' || gameState === 'goal'){
    update(dt);
    updateHUD();
  }
  draw();
  requestAnimationFrame(loop);
}

// ===== INPUT =====
document.addEventListener('keydown', e => {keys[e.code]=true;e.preventDefault();});
document.addEventListener('keyup', e => {keys[e.code]=false;});

// Touch controls
function detectMobile(){
  isMobile = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
  document.getElementById('touch-controls').style.display = isMobile ? 'block' : 'none';
}

// Joystick
const jArea = document.getElementById('joystick-area');
const jBase = document.getElementById('joystick-base');
const jThumb = document.getElementById('joystick-thumb');
let jTouch = null, jCenter = {x:0,y:0};

jArea.addEventListener('touchstart', e => {
  e.preventDefault();
  const t = e.changedTouches[0];
  jTouch = t.identifier;
  jCenter = {x:t.clientX, y:t.clientY};
  jBase.style.display = 'block';
  jThumb.style.display = 'block';
  jBase.style.left = (jCenter.x - 60) + 'px';
  jBase.style.top = (jCenter.y - 60) + 'px';
  jThumb.style.left = (jCenter.x - 25) + 'px';
  jThumb.style.top = (jCenter.y - 25) + 'px';
}, {passive:false});

jArea.addEventListener('touchmove', e => {
  e.preventDefault();
  for(const t of e.changedTouches){
    if(t.identifier === jTouch){
      let dx = t.clientX - jCenter.x;
      let dy = t.clientY - jCenter.y;
      const d = Math.sqrt(dx*dx+dy*dy);
      const maxR = 50;
      if(d > maxR){dx*=maxR/d;dy*=maxR/d;}
      jThumb.style.left = (jCenter.x + dx - 25) + 'px';
      jThumb.style.top = (jCenter.y + dy - 25) + 'px';
      joystickVec.x = dx/maxR;
      joystickVec.y = dy/maxR;
    }
  }
}, {passive:false});

jArea.addEventListener('touchend', e => {
  for(const t of e.changedTouches){
    if(t.identifier === jTouch){
      jTouch = null;
      joystickVec.x = 0; joystickVec.y = 0;
      jBase.style.display = 'none';
      jThumb.style.display = 'none';
    }
  }
});

document.getElementById('btn-shoot').addEventListener('touchstart', e => {e.preventDefault();shootPressed=true;}, {passive:false});
document.getElementById('btn-pass').addEventListener('touchstart', e => {e.preventDefault();passPressed=true;}, {passive:false});

// ===== START =====
document.getElementById('play-btn').addEventListener('click', () => {
  initAudio();
  document.getElementById('start-screen').style.display = 'none';
  document.getElementById('hud').style.display = 'flex';
  detectMobile();
  initGame();
  lastTime = performance.now();
  requestAnimationFrame(loop);
});
</script>
</body>
</html>
